---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types as sets

⟦_⟧ᵍ : GType → Set
⟦ Base B ⟧ᵍ = BaseSet B
⟦ Unit ⟧ᵍ   = ⊤
⟦ Empty ⟧ᵍ  = ⊥

-- Object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier (ConstTSet ⟦ param op ⟧ᵍ) t
       → ({t' : Time} → t + op-time op ≤ t'
                      → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t'
                      → Tˢ A τ t')
       → τ' ≡ op-time op + τ                                    -- abstracting into a variable for easier recursive defs.
       → Tˢ A τ' t


-- Monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {A} p (leaf a) =
  leaf (monotone A (+-monoʳ-≤ _ p) a)
Tˢ-≤t {A} p (node op v k q) =
  node op v (λ q y → k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y) q

Tˢ-≤t-refl : ∀ {A τ t} → (c : Tˢ A τ t) → Tˢ-≤t ≤-refl c ≡ c
Tˢ-≤t-refl {A} (leaf v) =
  cong
    leaf
    (trans
      (cong (λ p → monotone A p v) (≤-irrelevant _ ≤-refl))
      (monotone-refl A v))
Tˢ-≤t-refl {A} (node {τ} {τ'} {t} op v k p) =
  cong
    (λ (k : ({t' : Time} → t + op-time op ≤ t'
                         → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')) → node op v k p)
    (ifun-ext (fun-ext (λ q → fun-ext (λ y →
      cong (λ q → k q y) (≤-irrelevant _ _)))))

Tˢ-≤t-trans : ∀ {A τ t t' t''} → (p : t ≤ t') → (q : t' ≤ t'')
            → (c : Tˢ A τ t) → Tˢ-≤t q (Tˢ-≤t p c) ≡ Tˢ-≤t (≤-trans p q) c

Tˢ-≤t-trans {A} p q (leaf v) =
  cong
    leaf
    (trans
      (monotone-trans A _ _ v)
      (cong (λ p → monotone A p v) (≤-irrelevant _ _)))
Tˢ-≤t-trans {A} p q (node op v k r) =
  cong (λ (k : ({t' : Time} → _ + op-time op ≤ t'
                            → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t' → Tˢ A _ t'))
                            → node op (monotone (ConstTSet ⟦ param op ⟧ᵍ) (≤-trans p q) v) k r)
    (ifun-ext (fun-ext (λ s → fun-ext (λ y →
      cong (λ r → k r y) (≤-irrelevant _ _)))))

-- Functorial action on →ᵗ

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ f (leaf v)   =
  leaf (map-carrier f v)
Tˢᶠ f (node op v k q) =
  node op v (λ p y → Tˢᶠ f (k p y)) q

Tˢᶠ-nat : ∀ {A B τ} → (f : A →ᵗ B) → {t t' : ℕ}
        → (p : t ≤ t') → (c : Tˢ A τ t)
        → Tˢᶠ f (Tˢ-≤t p c) ≡ Tˢ-≤t p (Tˢᶠ f c)
        
Tˢᶠ-nat f p (leaf v) = cong leaf (map-nat f _ v)
Tˢᶠ-nat f p (node op v k q) = refl

-- Monotonicity wrt time-gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {A} p (leaf v) =
  leaf (monotone A (+-monoˡ-≤ _ p) v)
Tˢ-≤τ p (node op v k q) =
  node op v
    (λ r y → Tˢ-≤τ (proj₂ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (proj₁ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

Tˢ-≤τ-nat : ∀ {A τ τ'} → (p : τ ≤ τ') → {t t' : ℕ}
          → (q : t ≤ t') (c : Tˢ A τ t)
          → Tˢ-≤τ p (Tˢ-≤t q c) ≡ Tˢ-≤t q (Tˢ-≤τ p c)
Tˢ-≤τ-nat {A} p q (leaf v) =
  cong leaf
    (trans
      (monotone-trans A _ _ v)
      (trans
        (cong (λ r → monotone A r v) (≤-irrelevant _ _))
        (sym (monotone-trans A _ _ v))))
Tˢ-≤τ-nat p q (node op v k r) = refl

-- Packaging it all up into a functor

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f) (Tˢᶠ-nat f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p) (Tˢ-≤τ-nat p)

-- T is a [_]-module

T-[]-moduleˢ : ∀ {A τ τ' t} → Tˢ A τ' (t + τ) → Tˢ A (τ + τ') t
T-[]-moduleˢ {A} {τ} {τ'} {t} (leaf v) =
  leaf (monotone A (≤-reflexive (trans
                          (trans
                            (cong (τ' +_) (+-comm t τ))
                            (sym (+-assoc τ' τ t)))
                          (cong (_+ t) (+-comm τ' τ)))) v)
T-[]-moduleˢ {A} {τ} {τ'} {t} (node {τ = τ''} op v k p) =
  node op v
    (λ {t'} q y →
      T-[]-moduleˢ
        (k (≤-trans
             (≤-reflexive
               (trans
                 (+-assoc t τ (op-time op))
                   (trans
                     (cong (t +_) (+-comm τ (op-time op)))
                       (sym (+-assoc t (op-time op) τ)))))
             (+-monoˡ-≤ τ q))
           y))
    (trans
      (cong (τ +_) p)
      (trans
        (sym (+-assoc τ (op-time op) τ''))
        (trans
          (cong (_+ τ'') (+-comm τ (op-time op)))
          (+-assoc (op-time op) τ _))))

T-[]-moduleˢ-t-nat : ∀ {A τ τ' t t'}
                   → (p : t ≤ t') → (c : Tˢ A τ' (t + τ))
                   → T-[]-moduleˢ (Tˢ-≤t (+-mono-≤ p (≤-reflexive refl)) c)
                   ≡ Tˢ-≤t p (T-[]-moduleˢ c)

T-[]-moduleˢ-t-nat {A} p (leaf v) =
  cong leaf
    (trans
      (monotone-trans A _ _ v)
      (trans
        (cong (λ r → monotone A r v) (≤-irrelevant _ _))
        (sym (monotone-trans A _ _ v))))
T-[]-moduleˢ-t-nat p (node op v k q) =
  cong₂ (node op v)
    (ifun-ext (fun-ext (λ r → fun-ext (λ y →
      cong (λ s → T-[]-moduleˢ (k s y)) (≤-irrelevant _ _)))))
    refl

T-[]-module : ∀ {A τ τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')
T-[]-module = tset-map T-[]-moduleˢ T-[]-moduleˢ-t-nat 

-- Unit

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ {A} =
  tset-map
    (λ v → leaf v)
    (λ p x → cong leaf (cong (λ q → monotone A q x) (≤-irrelevant _ _)))

-- Multiplication

μˢ : ∀ {A τ τ'} → {t : Time}
   → carrier (Tᵒ (Tᵒ A τ') τ) t → carrier (Tᵒ A (τ + τ')) t
   
μˢ {A} {τ} {τ'} {t} (leaf c) =
  T-[]-moduleˢ (monotone (Tᵒ A τ') (≤-reflexive (+-comm τ t)) c)
μˢ (node op v k p) =
  node op v (λ q y → μˢ (k q y)) (trans (cong (_+ _) p) (+-assoc (op-time op) _ _))

μˢ-t-nat : ∀ {A τ τ' t t'}
         → (p : t ≤ t')
         → (c : Tˢ (tset (Tˢ A τ') Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans) τ t)
         → μˢ (Tˢ-≤t p c) ≡ Tˢ-≤t p (μˢ c)
μˢ-t-nat p (leaf c) =
  trans
    (cong T-[]-moduleˢ
      (trans
        (Tˢ-≤t-trans _ _ c)
        (trans
          (cong (λ q → Tˢ-≤t q c) (≤-irrelevant _ _))
          (sym (Tˢ-≤t-trans _ _ c)))))
    (T-[]-moduleˢ-t-nat p _)
μˢ-t-nat p (node op v k q) = refl

μᵀ : ∀ {A τ τ'} → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')
μᵀ = tset-map μˢ μˢ-t-nat

-- Strength

strˢ : ∀ {A B τ τ' t}
     → carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t → carrier (Tᵒ B τ) t
     → carrier (Tᵒ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ) t
     
strˢ {A} {B} {τ} {τ'} {t} (vp , vx) (leaf w) =
  leaf (
    (≤-trans vp (≤-reflexive (+-comm t τ)) ,
     monotone A (≤-reflexive (cong (_∸ τ') (+-comm t τ))) vx) ,
    w)
strˢ {A} {B} {τ' = τ''} {t} (vp , vx) (node {τ = τ} {τ' = τ'} op w k p) =
  node op w
    (λ q y →
      strˢ {A = A} {B = B} {τ = τ} {τ' = τ''}
        (≤-trans
           (≤-trans
             vp
             (≤-trans
               (≤-reflexive (cong (t +_) p))
               (≤-reflexive (sym (+-assoc t (op-time op) τ)))))
           (+-monoˡ-≤ τ q) ,
         monotone A
           (≤-trans
             (≤-reflexive (cong (λ τ' → t + τ' ∸ τ'') p))
             (≤-trans
               (≤-reflexive (cong (_∸ τ'') (sym (+-assoc t (op-time op) τ))))
               (∸-monoˡ-≤ τ'' (+-monoˡ-≤ τ q))))
           vx)
        (k q y))
    p

strˢ-t-nat : ∀ {A B τ τ'} → {t t' : ℕ} → (p : t ≤ t')
           → (x : carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A) ×ᵗ Tᵒ B τ) t)
           → strˢ {A = A} {B = B} (monotone ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) p (proj₁ x)) (Tˢ-≤t p (proj₂ x))
           ≡ Tˢ-≤t p (strˢ {A = A} {B = B} (proj₁ x) (proj₂ x))

strˢ-t-nat {A} p (x , leaf v) =
  cong leaf
    (cong₂ _,_
      (cong₂ _,_
        (≤-irrelevant _ _)
        (trans
          (monotone-trans A _ _ (proj₂ x))
          (trans
            (cong (λ q → monotone A q (proj₂ x)) (≤-irrelevant _ _))
            (sym (monotone-trans A _ _ (proj₂ x))))))
      refl)
strˢ-t-nat {A} p (x , node op v k q) =
  cong₂ (node op v)
    (ifun-ext (fun-ext (λ r → fun-ext (λ y →
      cong₂ strˢ
        (cong₂ _,_
          (≤-irrelevant _ _)
          (trans
            (monotone-trans A _ _ (proj₂ x))
            (cong (λ s → monotone A s (proj₂ x)) (≤-irrelevant _ _))))
        refl))))
    refl

strᵀ : ∀ {A B τ τ'} → [ τ ]ᵒ (⟨ τ' ⟩ᵒ A) ×ᵗ Tᵒ B τ →ᵗ Tᵒ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ
strᵀ {A} {B} {τ} {τ'} =
  tset-map (λ { (v , c) → strˢ {A} {B} {τ} {τ'} v c }) strˢ-t-nat

-- Algebraic operations

-- note: op's continuation executes after `op-time op` time steps

opᵀ : ∀ {A τ} → (op : Op)
    → ConstTSet ⟦ param op ⟧ᵍ ×ᵗ [ op-time op ]ᵒ (ConstTSet ⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)
   →ᵗ Tᵒ A (op-time op + τ)
   
opᵀ {A} {τ} op =
  tset-map
    (λ { (v , k) → node op v (λ p y → map-carrier k (p , y)) refl })
    (λ { p (x , k) → refl })

{-
-- Semantics of effect handling (the mediating
-- homomorphism induced by a given algebra)

handleˢ : ∀ {A B τ τ' t}
        → carrier (Tᵒ A τ) t
        → ((op : Op) → (τ'' : Time) →
             {t' : Time} → t ≤ t' → 
             carrier (ConstTSet ⟦ param op ⟧ᵍ) t' →
             ({t'' : Time} → t' + op-time op ≤ t'' →
                carrier (ConstTSet ⟦ arity op ⟧ᵍ) t'' → carrier (Tᵒ B τ'') t'') →
             carrier (Tᵒ B (op-time op + τ'')) t')
        → ({t' : Time} → t + τ ≤ t' → carrier A t' → carrier (Tᵒ B τ') t')
        → carrier (Tᵒ B (τ + τ')) t
        
handleˢ {τ = τ} {t = t} (leaf v) h k =
  T-[]-moduleˢ
    (Tˢ-≤t
      (≤-reflexive (+-comm τ t))
      (k (≤-reflexive (+-comm t τ)) v))
handleˢ {τ' = τ'} {t = t} (node {τ = τ''} op v k refl) h k' =
  Tˢ-≤τ
    (≤-reflexive (sym (+-assoc (op-time op) τ'' τ')))
    (h op (τ'' + τ') ≤-refl v
      (λ q y →
        handleˢ
          (k q y)
          (λ op τ''' r x k'' →
            h op τ'''
              (≤-trans (m+n≤o⇒m≤o t q) r)
              x
              k'')
          (λ r z →
            k' (≤-trans
                 (≤-trans
                   (≤-reflexive (sym (+-assoc t (op-time op) τ'')))
                   (+-monoˡ-≤ τ'' q)) r) z)))

handleᵀ : ∀ {A B τ τ'}
        → Tᵒ A τ
       ×ᵗ Π Op (λ op → Π Time (λ τ'' →
           ConstTSet ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (ConstTSet ⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ B τ'')))
             ⇒ᵗ Tᵒ B (op-time op + τ'')))
       ×ᵗ [ τ ]ᵒ (A ⇒ᵗ Tᵒ B τ')
        →ᵗ Tᵒ B (τ + τ')

handleᵀ = tset-map (λ { (c , h , k) →
  handleˢ c (λ op τ'' p x k' →
    h op τ'' p (x , λ q y → k' q y)) k })

-}
