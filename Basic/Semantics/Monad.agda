---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types as sets

⟦_⟧ᵍ : GType → Set
⟦ Base B ⟧ᵍ = BaseSet B
⟦ Unit ⟧ᵍ   = ⊤
⟦ Empty ⟧ᵍ  = ⊥

-- Semantic constants for base types

constᵗ : ∀ {B} → BaseSet B → 𝟙ᵗ →ᵗ ConstTSet (BaseSet B)
constᵗ c = tset-map (λ _ → c)

-- Object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier (ConstTSet ⟦ param op ⟧ᵍ) t
       → ({t' : Time} → t + op-time op ≤ t'                     -- `[ op-time op ] (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)`; more convenient
                      → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t'    -- than `⟦ arity op ⟧ᵍ ⇒ᵗ [ op-time op ] (Tᵒ A τ)` for Agda
                      → Tˢ A τ t')                              -- to see that the function `T-[]-moduleˢ` below terminates
       → τ' ≡ op-time op + τ                                    -- abstracting into a variable for easier recursive defs.
       → Tˢ A τ' t

-- Monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {A} p (leaf a) =
  leaf (monotone A (+-monoʳ-≤ _ p) a)
Tˢ-≤t {A} p (node op v k q) =
  node op v (λ q y → k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y) q

Tˢ-≤t-refl : ∀ {A τ t} → (c : Tˢ A τ t) → Tˢ-≤t ≤-refl c ≡ c
Tˢ-≤t-refl {A} (leaf v) =
  cong
    leaf
    (trans
      (cong (λ p → monotone A p v) (≤-irrelevant _ ≤-refl))
      (monotone-refl A v))
Tˢ-≤t-refl {A} (node {τ} {τ'} {t} op v k p) =
  cong
    (λ (k : ({t' : Time} → t + op-time op ≤ t'
                         → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')) → node op v k p)
    (ifun-ext (fun-ext (λ q → fun-ext (λ y →
      cong (λ q → k q y) (≤-irrelevant _ _)))))

Tˢ-≤t-trans : ∀ {A τ t t' t''} → (p : t ≤ t') → (q : t' ≤ t'')
            → (c : Tˢ A τ t) → Tˢ-≤t q (Tˢ-≤t p c) ≡ Tˢ-≤t (≤-trans p q) c

Tˢ-≤t-trans {A} p q (leaf v) =
  cong
    leaf
    (trans
      (monotone-trans A _ _ v)
      (cong (λ p → monotone A p v) (≤-irrelevant _ _)))
Tˢ-≤t-trans {A} p q (node op v k r) =
  cong (λ (k : ({t' : Time} → _ + op-time op ≤ t'
                            → carrier (ConstTSet ⟦ arity op ⟧ᵍ) t' → Tˢ A _ t'))
                            → node op (monotone (ConstTSet ⟦ param op ⟧ᵍ) (≤-trans p q) v) k r)
    (ifun-ext (fun-ext (λ s → fun-ext (λ y →
      cong (λ r → k r y) (≤-irrelevant _ _)))))

-- Monotonicity wrt time-gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {A} p (leaf v) =
  leaf (monotone A (+-monoˡ-≤ _ p) v)
Tˢ-≤τ p (node op v k q) =
  node op v
    (λ r y → Tˢ-≤τ (proj₂ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (proj₁ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

-- Functorial action on →ᵗ

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ (tset-map f) (leaf a)   =
  leaf (f a)
Tˢᶠ (tset-map f) (node op v k q) =
  node op v (λ p y → Tˢᶠ (tset-map f) (k p y)) q

-- Packaging it all up into a functor

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p)

-- T is a [_]-module

T-[]-moduleˢ : ∀ {A τ τ' t} → Tˢ A τ' (t + τ) → Tˢ A (τ + τ') t
T-[]-moduleˢ {A} {τ} {τ'} {t} (leaf v) =
  leaf (monotone A (≤-reflexive (trans
                          (trans
                            (cong (τ' +_) (+-comm t τ))
                            (sym (+-assoc τ' τ t)))
                          (cong (_+ t) (+-comm τ' τ)))) v)
T-[]-moduleˢ {A} {τ} {τ'} {t} (node {τ = τ''} op v k p) =
  node op v
    (λ {t'} q y →
      T-[]-moduleˢ
        (k (≤-trans
             (≤-reflexive
               (trans
                 (+-assoc t τ (op-time op))
                   (trans
                     (cong (t +_) (+-comm τ (op-time op)))
                       (sym (+-assoc t (op-time op) τ)))))
             (+-monoˡ-≤ τ q))
           y))
    (trans
      (cong (τ +_) p)
      (trans
        (sym (+-assoc τ (op-time op) τ''))
        (trans
          (cong (_+ τ'') (+-comm τ (op-time op)))
          (+-assoc (op-time op) τ _))))

T-[]-module : ∀ {A τ τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')
T-[]-module = tset-map T-[]-moduleˢ

-- Unit

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ = tset-map (λ v → leaf v)

-- Multiplication

μˢ : ∀ {A τ τ'} → {t : Time}
   → carrier (Tᵒ (Tᵒ A τ') τ) t → carrier (Tᵒ A (τ + τ')) t
   
μˢ {A} {τ} {τ'} {t} (leaf c) =
  T-[]-moduleˢ (monotone (Tᵒ A τ') (≤-reflexive (+-comm τ t)) c)
μˢ (node op v k p) =
  node op v (λ q y → μˢ (k q y)) (trans (cong (_+ _) p) (+-assoc (op-time op) _ _))

μᵀ : ∀ {A τ τ'} → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')
μᵀ = tset-map μˢ

-- Strength

strˢ : ∀ {A B τ τ' t}
     → carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t → carrier (Tᵒ B τ) t
     → carrier (Tᵒ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ) t
     
strˢ {A} {B} {τ} {τ'} {t} (vp , vx) (leaf w) =
  leaf (
    (≤-trans vp (≤-reflexive (+-comm t τ)) ,
     monotone A (≤-reflexive (cong (_∸ τ') (+-comm t τ))) vx) ,
    w)
strˢ {A} {B} {τ' = τ''} {t} (vp , vx) (node {τ = τ} {τ' = τ'} op w k p) =
  node op w
    (λ q y →
      strˢ {A = A} {B = B} {τ = τ} {τ' = τ''}
        (≤-trans
           (≤-trans
             vp
             (≤-trans
               (≤-reflexive (cong (t +_) p))
               (≤-reflexive (sym (+-assoc t (op-time op) τ)))))
           (+-monoˡ-≤ τ q) ,
         monotone A
           (≤-trans
             (≤-reflexive (cong (λ τ' → t + τ' ∸ τ'') p))
             (≤-trans
               (≤-reflexive (cong (_∸ τ'') (sym (+-assoc t (op-time op) τ))))
               (∸-monoˡ-≤ τ'' (+-monoˡ-≤ τ q))))
           vx)
        (k q y))
    p

strᵀ : ∀ {A B τ τ'} → [ τ ]ᵒ (⟨ τ' ⟩ᵒ A) ×ᵗ Tᵒ B τ →ᵗ Tᵒ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ
strᵀ {A} {B} {τ} {τ'} = tset-map λ { (v , c) → strˢ {A} {B} {τ} {τ'} v c }

-- Algebraic operations

-- More standard `⟦ arity op ⟧ᵍ ⇒ᵗ [ op-time op ] (Tᵒ A τ)`
-- presentation compared tot he one used in the def. of `Tᵒ`

opᵀ : ∀ {A τ} → (op : Op)
    → ConstTSet ⟦ param op ⟧ᵍ ×ᵗ (ConstTSet ⟦ arity op ⟧ᵍ ⇒ᵗ [ op-time op ]ᵒ (Tᵒ A τ)) →ᵗ Tᵒ A (op-time op + τ)
opᵀ {A} {τ} op =
     tset-map (λ { (v , k) → node op v (λ {t'} → k {t'}) refl })
  ∘ᵗ mapˣᵗ idᵗ (⇒ᵗ-[] {B = Tᵒ A τ} {τ = op-time op})

-- Semantics of effect handling (the mediating
-- homomorphism induced by a given algebra)

handleˢ : ∀ {A B τ τ' t}
        → carrier (Tᵒ A τ) t
        → ((op : Op) → (τ'' : Time) →
             {t' : Time} → t ≤ t' → 
             carrier (ConstTSet ⟦ param op ⟧ᵍ) t' →
             ({t'' : Time} → t' + op-time op ≤ t'' →
                carrier (ConstTSet ⟦ arity op ⟧ᵍ) t'' → carrier (Tᵒ B τ'') t'') →
             carrier (Tᵒ B (op-time op + τ'')) t')
        → ({t' : Time} → t + τ ≤ t' → carrier A t' → carrier (Tᵒ B τ') t')
        → carrier (Tᵒ B (τ + τ')) t
        
handleˢ {τ = τ} {t = t} (leaf v) h k =
  T-[]-moduleˢ
    (Tˢ-≤t
      (≤-reflexive (+-comm τ t))
      (k (≤-reflexive (+-comm t τ)) v))
handleˢ {τ' = τ'} {t = t} (node {τ = τ''} op v k refl) h k' =
  Tˢ-≤τ
    (≤-reflexive (sym (+-assoc (op-time op) τ'' τ')))
    (h op (τ'' + τ') ≤-refl v
      (λ q y →
        handleˢ
          (k q y)
          (λ op τ''' r x k'' →
            h op τ'''
              (≤-trans (m+n≤o⇒m≤o t q) r)
              x
              k'')
          (λ r z →
            k' (≤-trans
                 (≤-trans
                   (≤-reflexive (sym (+-assoc t (op-time op) τ'')))
                   (+-monoˡ-≤ τ'' q)) r) z)))

handleᵀ : ∀ {A B τ τ'}
        → Tᵒ A τ ×ᵗ
          Π Op (λ op → Π Time (λ τ'' →
           ConstTSet ⟦ param op ⟧ᵍ ×ᵗ (ConstTSet ⟦ arity op ⟧ᵍ ⇒ᵗ [ op-time op ]ᵒ (Tᵒ B τ'')) ⇒ᵗ Tᵒ B (op-time op + τ''))) ×ᵗ
          [ τ ]ᵒ (A ⇒ᵗ Tᵒ B τ')
        →ᵗ Tᵒ B (τ + τ')

handleᵀ = tset-map (λ { (c , h , k) →
  handleˢ c (λ op τ'' p x k' →
    h op τ'' p (x , λ q y → k' (+-monoˡ-≤ (op-time op) q) y)) k })
