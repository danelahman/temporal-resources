---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types

-- Note: To apply Adamek's theorem to construct T, likely
-- want to limit them to finite, countable, etc presheaves

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ   = ConstTSet (BaseSet B)
⟦ Unit ⟧ᵍ     = 𝟙ᵗ
⟦ Empty ⟧ᵍ    = 𝟘ᵗ
⟦ [ τ ]ᵍ A ⟧ᵍ = [ τ ]ᵒ ⟦ A ⟧ᵍ

-- The free graded monad generated by the operations in Op

-- TODO: work out all formal details of the corresponding
--       definitions (postulating them below for time being)

postulate

  -- Object-mapping

  Tᵒ : TSet → Time → TSet

  -- Functorial action

  Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ

  -- Monotonicity wrt. gradings

  -- Note: This would correspond to syntactic sub-effecting,
  -- but the current language doesn't seem to readily support
  -- it. For example, consider the equation/reduction
  --
  --   coerce (p : 0 ≤ τ') (return V) ; N ~> coerce ... N[V/x]
  --
  -- where if the LHS is typed according to the obvious
  -- rule, N would be typed in a context `Γ ⟨ τ' ⟩ ∷ A`
  -- but this cannot be turned into a context `Γ ∷ A` as
  -- needed in the RHS of the equation/reduction. Instead
  -- it seems to remain the case that one needs to use the
  -- explicit delays instead of sub-effecting coercions.

  -- T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'

  -- Unit

  ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0

  -- Multiplication

  μᵀ : ∀ {A τ τ'} → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')

  -- Strength

  strᵀ : ∀ {A B τ} → [ τ ]ᵒ A ×ᵗ Tᵒ B τ →ᵗ Tᵒ (A ×ᵗ B) τ

  -- Delay operation (T is a kind of a [_]-module)

  T-delay : ∀ {A τ τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')

  -- Algebraic operations

  opᵀ : ∀ {A τ} → (op : Op)
      → ⟦ param op ⟧ᵍ ×ᵗ [ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ) →ᵗ Tᵒ A (op-time op + τ)

  -- T-algebra induced by an effect handler

  alg-of-handler : ∀ {A τ τ'}
                 → Π Op (λ op → Π Time (λ τ'' →
                    ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                      ⇒ᵗ Tᵒ A (op-time op + τ'')))
                 →ᵗ Tᵒ (Tᵒ A τ') τ ⇒ᵗ (Tᵒ A (τ + τ'))


---------------------------------------------------------
---------------------------------------------------------


-- Candidate for object-mapping of the underlying functor

-- Note: organised into two mutually given definitions so
--       as to model the refl/trans rules for delays

mutual
  
  data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : ∀ {τ' t}
          → (τ : Time)
          → 0 < τ
          → Tᶜˢ A τ' (t + τ)
          → Tˢ A (τ + τ') t

    comp  : ∀ {τ t}
          → Tᶜˢ A τ t
          → Tˢ A τ t

  data Tᶜˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : ∀ {t}
          → carrier A t
          → Tᶜˢ A 0 t
     
    node  : ∀ {τ t}
          → (op : Op)
          → carrier ⟦ param op ⟧ᵍ t
          → ({t' : Time} → t + op-time op ≤ t'
                         → carrier ⟦ arity op ⟧ᵍ t'
                         → Tˢ A τ t')
          → Tᶜˢ A (op-time op + τ) t
