---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad where

-- Interpretation of ground types
---------------------------------

-- Note: To apply Adamek's theorem to construct T, likely
-- want to limit them to finite, countable, etc presheaves

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ   = ConstTSet (BaseSet B)
⟦ Unit ⟧ᵍ     = 𝟙ᵗ
⟦ Empty ⟧ᵍ    = 𝟘ᵗ
⟦ [ τ ]ᵍ A ⟧ᵍ = [ τ ]ᵒ ⟦ A ⟧ᵍ

-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Skeletal object mapping

mutual
  
  data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : ∀ {τ' t}
          → (τ : Time)
          → 0 < τ
          → Tᶜˢ A τ' (t + τ)
          → Tˢ A (τ + τ') t

    comp  : ∀ {τ t}
          → Tᶜˢ A τ t
          → Tˢ A τ t

  data Tᶜˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : ∀ {t}
          → carrier A t
          → Tᶜˢ A 0 t
     
    node  : ∀ {τ t}
          → (op : Op)
          → carrier ⟦ param op ⟧ᵍ t
          → ({t' : Time} → t + op-time op ≤ t'
                         → carrier ⟦ arity op ⟧ᵍ t'
                         → Tˢ A τ t')
          → Tᶜˢ A (op-time op + τ) t

-- Monotonicity with respect to the (presheaf) time indices

mutual

  Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
  
  Tˢ-≤t p (delay τ q k) =
    delay τ q (Tᶜˢ-≤t (+-monoˡ-≤ τ p) k)
  Tˢ-≤t p (comp k) =
    comp (Tᶜˢ-≤t p k)

  Tᶜˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tᶜˢ A τ t → Tᶜˢ A τ t'
  
  Tᶜˢ-≤t {A} p (leaf v) =
    leaf (monotone A p v)
  Tᶜˢ-≤t p (node op v k) =
    node op
      (monotone (⟦ param op ⟧ᵍ) p v)
      (λ {t'} q y → k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)

  Tˢ-≤t-refl : ∀ {A τ t} → (c : Tˢ A τ t) → Tˢ-≤t ≤-refl c ≡ c
  
  Tˢ-≤t-refl (delay τ q k) =
    cong (delay τ q)
      (trans
        (cong (λ p → Tᶜˢ-≤t p k) (≤-irrelevant _ _))
        (Tᶜˢ-≤t-refl k))
  Tˢ-≤t-refl (comp k) =
    cong comp (Tᶜˢ-≤t-refl k)

  Tᶜˢ-≤t-refl : ∀ {A τ t} → (c : Tᶜˢ A τ t) → Tᶜˢ-≤t ≤-refl c ≡ c
  
  Tᶜˢ-≤t-refl {A} (leaf v) =
    cong leaf (monotone-refl A v)
  Tᶜˢ-≤t-refl (node op v k) =
    cong₂ (node op)
      (monotone-refl ⟦ param op ⟧ᵍ v)
      (ifun-ext (fun-ext (λ q → cong k (≤-irrelevant _ _))))

  Tˢ-≤t-trans : ∀ {A τ t t' t''}
              → (p : t ≤ t') → (q : t' ≤ t'') → (c : Tˢ A τ t)
              → Tˢ-≤t q (Tˢ-≤t p c) ≡ Tˢ-≤t (≤-trans p q) c
              
  Tˢ-≤t-trans {A} p q (delay τ r k) =
    cong (delay τ r)
      (trans
        (Tᶜˢ-≤t-trans (+-monoˡ-≤ τ p) (+-monoˡ-≤ τ q) k)
        (cong (λ p → Tᶜˢ-≤t p k) (≤-irrelevant _ _)))
  Tˢ-≤t-trans p q (comp k) =
    cong comp (Tᶜˢ-≤t-trans p q k)

  Tᶜˢ-≤t-trans : ∀ {A τ t t' t''}
               → (p : t ≤ t') → (q : t' ≤ t'') → (c : Tᶜˢ A τ t)
               → Tᶜˢ-≤t q (Tᶜˢ-≤t p c) ≡ Tᶜˢ-≤t (≤-trans p q) c

  Tᶜˢ-≤t-trans {A} p q (leaf v) =
    cong leaf (monotone-trans A p q v)
  Tᶜˢ-≤t-trans p q (node op v k) =
    cong₂ (node op)
      (monotone-trans ⟦ param op ⟧ᵍ p q v)
      (ifun-ext (fun-ext (λ r → cong k (≤-irrelevant _ _))))

-- Functorial action

mutual

  Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
  
  Tˢᶠ f (delay τ p k) =
    delay τ p (Tᶜˢᶠ f k)
  Tˢᶠ f (comp k) =
    comp (Tᶜˢᶠ f k)

  Tᶜˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tᶜˢ A τ t → Tᶜˢ B τ t
  
  Tᶜˢᶠ f (leaf v) =
    leaf (map-carrier f v)
  Tᶜˢᶠ f (node op v k) =
    node op v (λ p y → Tˢᶠ f (k p y))

  Tˢᶠ-nat : ∀ {A B τ} → (f : A →ᵗ B) → {t t' : ℕ}
          → (p : t ≤ t') → (c : Tˢ A τ t)
          → Tˢᶠ f (Tˢ-≤t p c) ≡ Tˢ-≤t p (Tˢᶠ f c)

  Tˢᶠ-nat f p (delay τ q k) =
    cong (delay τ q) (Tᶜˢᶠ-nat f (+-monoˡ-≤ τ p) k)
  Tˢᶠ-nat f p (comp k) =
    cong comp (Tᶜˢᶠ-nat f p k)

  Tᶜˢᶠ-nat : ∀ {A B τ} → (f : A →ᵗ B) → {t t' : ℕ}
           → (p : t ≤ t') → (c : Tᶜˢ A τ t)
           → Tᶜˢᶠ f (Tᶜˢ-≤t p c) ≡ Tᶜˢ-≤t p (Tᶜˢᶠ f c)

  Tᶜˢᶠ-nat f p (leaf v) =
    cong leaf (map-nat f p v)
  Tᶜˢᶠ-nat f p (node op v k) =
    cong₂ (node op) refl refl

-- Packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (Tˢ A τ) Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f) (Tˢᶠ-nat f)

-- Unit

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ =
  tset-map
    (λ v → comp (leaf v))
    (λ p v → refl)

-- Multiplication

mutual
  μˢ : ∀ {A τ τ'} → {t : Time}
     → Tˢ (Tᵒ A τ') τ t → Tˢ A (τ + τ') t

  μˢ {A} {t = t} (delay τ p k) with μᶜˢ k
  ... | _ , q , delay {τ' = τ''} τ' r k' =
    subst
      (λ τ → Tˢ A τ t)
      (trans
        (+-assoc τ _ _)
        (trans
          (cong (τ +_) q)
          (sym (+-assoc τ _ _))))
      (delay (τ + τ')
        (≤-trans r (m≤n+m τ' τ))
        (subst (λ t → Tᶜˢ A τ'' t)
          (+-assoc t _ _) k'))
  ... | _ , refl , comp k' =
    subst (λ τ → Tˢ A τ t) (sym (+-assoc τ _ _)) (delay τ p k')
  μˢ {A} {τ} {τ'} {t} (comp k) with μᶜˢ k
  ... | _ , p , delay τ'' q k' =
    subst (λ τ → Tˢ A τ t) p (delay τ'' q k')
  ... | _ , refl , comp k =
    comp k

  μᶜˢ : ∀ {A τ τ'} → {t : Time}
      → Tᶜˢ (Tᵒ A τ') τ t → Σ[ τ'' ∈ Time ] (τ'' ≡ τ + τ' × Tˢ A τ'' t)

  μᶜˢ (leaf c) = _ , refl , c
  μᶜˢ {A = A} {t = t} (node op v k) =
    _ , refl , comp (subst
                      (λ τ → Tᶜˢ A τ t)
                      (sym (+-assoc (op-time op) _ _))
                      (node op v λ p y → μˢ (k p y)))

  μˢ-t-nat : ∀ {A τ τ' t t'}
           → (p : t ≤ t')
           → (c : Tˢ (Tᵒ A τ') τ t)
           → μˢ (Tˢ-≤t p c) ≡ Tˢ-≤t p (μˢ c)

  μˢ-t-nat p (delay τ q k) = {!!}
  μˢ-t-nat p (comp k) = {!!}

  μᶜˢ-t-nat : ∀ {A τ τ' t t'}
           → (p : t ≤ t')
           → (c : Tᶜˢ (Tᵒ A τ') τ t)
           → {!!} --μᶜˢ (Tᶜˢ-≤t p c) ≡ Tᶜˢ-≤t p (μᶜˢ c)

  μᶜˢ-t-nat = {!!}









{-
-- TODO: work out all formal details of the corresponding
--       definitions (postulating them below for time being)

postulate

  -- Object-mapping

  Tᵒ : TSet → Time → TSet

  -- Functorial action

  Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ

  -- Monotonicity wrt. gradings

  -- Note: This would correspond to syntactic sub-effecting,
  -- but the current language doesn't seem to readily support
  -- it. For example, consider the equation/reduction
  --
  --   coerce (p : 0 ≤ τ') (return V) ; N ~> coerce ... N[V/x]
  --
  -- where if the LHS is typed according to the obvious
  -- rule, N would be typed in a context `Γ ⟨ τ' ⟩ ∷ A`
  -- but this cannot be turned into a context `Γ ∷ A` as
  -- needed in the RHS of the equation/reduction. Instead
  -- it seems to remain the case that one needs to use the
  -- explicit delays instead of sub-effecting coercions.

  -- T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'

  -- Unit

  ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0

  -- Multiplication

  μᵀ : ∀ {A τ τ'} → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')

  -- Strength

  strᵀ : ∀ {A B τ} → [ τ ]ᵒ A ×ᵗ Tᵒ B τ →ᵗ Tᵒ (A ×ᵗ B) τ

  -- Delay operation (T is a kind of a [_]-module)

  T-delay : ∀ {A τ τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')

  -- Algebraic operations

  opᵀ : ∀ {A τ} → (op : Op)
      → ⟦ param op ⟧ᵍ ×ᵗ [ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ) →ᵗ Tᵒ A (op-time op + τ)

  -- T-algebra induced by an effect handler

  alg-of-handler : ∀ {A τ τ'}
                 → Π Op (λ op → Π Time (λ τ'' →
                    ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                      ⇒ᵗ Tᵒ A (op-time op + τ'')))
                 →ᵗ Tᵒ (Tᵒ A τ') τ ⇒ᵗ (Tᵒ A (τ + τ'))


---------------------------------------------------------
---------------------------------------------------------


-- Candidate for object-mapping of the underlying functor

-- Note: organised into two mutually given definitions so
--       as to model the refl/trans rules for delays

mutual
  
  data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : ∀ {τ' t}
          → (τ : Time)
          → 0 < τ
          → Tᶜˢ A τ' (t + τ)
          → Tˢ A (τ + τ') t

    comp  : ∀ {τ t}
          → Tᶜˢ A τ t
          → Tˢ A τ t

  data Tᶜˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : ∀ {t}
          → carrier A t
          → Tᶜˢ A 0 t
     
    node  : ∀ {τ t}
          → (op : Op)
          → carrier ⟦ param op ⟧ᵍ t
          → ({t' : Time} → t + op-time op ≤ t'
                         → carrier ⟦ arity op ⟧ᵍ t'
                         → Tˢ A τ t')
          → Tᶜˢ A (op-time op + τ) t
-}
