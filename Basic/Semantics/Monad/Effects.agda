---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past
open import Semantics.Monad.Core

open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad.Effects where

-- The free graded monad generated by the operations in Op (continued)
----------------------------------------------------------------------

-- Delay operation (T is a kind of a [_]-module)

delayᵀ : ∀ {A} (τ : Time) {τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')
delayᵀ τ =
  tset-map
    (delay τ)
    (λ p c → refl)


-- Algebraic operations

opᵀ : ∀ {A τ} → (op : Op)
    → ⟦ param op ⟧ᵍ ×ᵗ [ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ) →ᵗ Tᵒ A (op-time op + τ)
opᵀ {A} {τ} op =
  tset-map
    (λ {t} vk →
      node op
        (proj₁ (unpack-×ᵗ vk))
        (λ p y →
          map-carrier
            (unpack-⇒ᵗ (proj₂ (unpack-×ᵗ vk)))
            (pack-×ᵗ (pack-homᵒ (t + op-time op) p , y)))
        (λ p q y →
          trans
            (cong (map-carrier (unpack-⇒ᵗ (proj₂ (unpack-×ᵗ vk))))
              (trans
                (cong pack-×ᵗ
                  (cong (_, monotone ⟦ arity op ⟧ᵍ p y)
                    (sym (pack-homᵒ-monotone _ _))))
                (sym (pack-×ᵗ-monotone _ _))))
            (map-nat (unpack-⇒ᵗ (proj₂ (unpack-×ᵗ vk))) _ _)))
    (λ {t} {t'} p k →
      dcong₃ (node op)
        (sym (cong proj₁ (unpack-×ᵗ-monotone _ k)))
        (ifun-ext (fun-ext (λ q → fun-ext (λ y →
          trans
            (cong (λ (k : {t' : Time} → _ + op-time op ≤ t' → carrier ⟦ arity op ⟧ᵍ t' → Tˢ A _ t') → k q y)
              (subst-const _ (sym (cong proj₁ (unpack-×ᵗ-monotone p k))) _))
            (trans
              (cong (λ (f : homᵒ (t' + op-time op) ×ᵗ ⟦ arity op ⟧ᵍ →ᵗ Tᵒ A τ) → map-carrier f (pack-×ᵗ (pack-homᵒ (t' + op-time op) q , y)))
                {(unpack-⇒ᵗ (proj₂ (unpack-×ᵗ (monotone (⟦ param op ⟧ᵍ ×ᵗ [ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)) p k))))}
                {(unpack-⇒ᵗ (monotone (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ) (+-mono-≤ p ≤-refl) (proj₂ (unpack-×ᵗ k))))}
                (cong unpack-⇒ᵗ (sym (cong proj₂ (unpack-×ᵗ-monotone _ _)))))
              (unpack-⇒ᵗ-map-carrier (proj₂ (unpack-×ᵗ k)) _ _ y))))))
        (ifun-ext (ifun-ext (fun-ext (λ q → fun-ext (λ r → fun-ext (λ y → uip)))))))


-- T-algebra induced by an effect handler

mutual

  {-# TERMINATING #-}

  T-alg-of-handlerˢ : ∀ {A τ τ' t}
                    → carrier (Π Op (λ op → Π Time (λ τ'' →
                        ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                          ⇒ᵗ Tᵒ A (op-time op + τ'')))) t
                    → {t' : Time}
                    → t ≤ t'
                    → Tˢ (Tᵒ A τ') τ t'
                    → Tˢ A (τ + τ') t'

  T-alg-of-handlerˢ h p (leaf c) =
    c
  T-alg-of-handlerˢ h p (node op v k k-nat) =
    τ-subst
      (sym (+-assoc (op-time op) _ _))
      (node op v
        (λ q y → T-alg-of-handlerˢ h (≤-trans p (m+n≤o⇒m≤o _ q)) (k q y))
        (λ q r y →
          trans
            (cong₂ (T-alg-of-handlerˢ h) (≤-irrelevant _ _) (k-nat q r y))
            (T-alg-of-handlerˢ-≤t-cod-nat _ h q (k r y))))
  T-alg-of-handlerˢ h p (delay τ k) =
    τ-subst
      (sym (+-assoc τ _ _))
      (delay τ
        (T-alg-of-handlerˢ h (≤-stepsʳ τ p) k))

  T-alg-of-handlerˢ-≤t-cod-nat : ∀ {A τ τ'} → {t t' : ℕ} → (p : t ≤ t')
                               → (h : carrier (Π Op (λ op → Π Time (λ τ'' →
                                        ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                                          ⇒ᵗ Tᵒ A (op-time op + τ'')))) t)
                               → {t'' : Time}
                               → (q : t' ≤ t'')
                               → (c : Tˢ (Tᵒ A τ') τ t')
                               → T-alg-of-handlerˢ h (≤-trans p q) (Tˢ-≤t q c)
                               ≡ Tˢ-≤t q (T-alg-of-handlerˢ h p c)
                           
  T-alg-of-handlerˢ-≤t-cod-nat p h q (leaf v) =
    refl
  T-alg-of-handlerˢ-≤t-cod-nat p h q (node op v k k-nat) =
    trans
      (cong (τ-subst (sym (+-assoc (op-time op) _ _)))
        (dcong₂ (node op (monotone ⟦ param op ⟧ᵍ q v))
          (ifun-ext (fun-ext (λ r → fun-ext (λ y →
            cong (λ p → T-alg-of-handlerˢ h p (k (≤-trans (+-monoˡ-≤ (op-time op) q) r) y)) (≤-irrelevant _ _)))))
          (ifun-ext (ifun-ext (fun-ext (λ r → fun-ext (λ s → fun-ext (λ y → uip))))))))
      (sym (τ-subst-≤t (sym (+-assoc (op-time op) _ _)) _ _))
  T-alg-of-handlerˢ-≤t-cod-nat p h q (delay τ k) =
    trans
      (cong (τ-subst (sym (+-assoc τ _ _)))
        (cong (delay τ)
          (trans
            (cong (λ p → T-alg-of-handlerˢ h p (Tˢ-≤t (+-monoˡ-≤ τ q) k)) (≤-irrelevant _ _))
            (T-alg-of-handlerˢ-≤t-cod-nat (≤-stepsʳ τ p) h (+-monoˡ-≤ τ q) k))))
      (sym (τ-subst-≤t (sym (+-assoc τ _ _)) q _))

  T-alg-of-handlerˢ-≤t-nat : ∀ {A τ τ'} → {t t' : ℕ} → (p : t ≤ t')
                           → (h : carrier (Π Op (λ op → Π Time (λ τ'' →
                                    ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                                      ⇒ᵗ Tᵒ A (op-time op + τ'')))) t)
                           → {t'' : Time}
                           → (q : t' ≤ t'')
                           → (c : Tˢ (Tᵒ A τ') τ t'')
                           → T-alg-of-handlerˢ
                               (monotone (Π Op (λ op → Π Time (λ τ'' →
                                           ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ
                                             ⇒ᵗ (Tᵒ A τ''))) ⇒ᵗ Tᵒ A (op-time op + τ'')))) p h)
                               q c
                           ≡ T-alg-of-handlerˢ h (≤-trans p q) c
  T-alg-of-handlerˢ-≤t-nat p h q (leaf v) =
    refl
  T-alg-of-handlerˢ-≤t-nat p h q (node op v k k-nat) =
    cong (τ-subst (sym (+-assoc (op-time op) _ _)))
      (dcong₂ (node op v)
        (ifun-ext (fun-ext (λ r → fun-ext (λ y →
          trans
            (T-alg-of-handlerˢ-≤t-nat p h _ (k r y))
            (cong (λ p → T-alg-of-handlerˢ h p (k r y)) (≤-irrelevant _ _))))))
        (ifun-ext (ifun-ext (fun-ext (λ r → fun-ext (λ s → fun-ext (λ y → uip)))))))
  T-alg-of-handlerˢ-≤t-nat p h q (delay τ k) =
    cong (τ-subst (sym (+-assoc τ _ _)))
      (cong (delay τ)
        (trans
          (T-alg-of-handlerˢ-≤t-nat p h _ k)
          (cong (λ p → T-alg-of-handlerˢ h p k) (≤-irrelevant _ _))))

T-alg-of-handlerᵀ : ∀ {A τ τ'}
                  → Π Op (λ op → Π Time (λ τ'' →
                     ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                       ⇒ᵗ Tᵒ A (op-time op + τ'')))
                  →ᵗ Tᵒ (Tᵒ A τ') τ ⇒ᵗ Tᵒ A (τ + τ')
T-alg-of-handlerᵀ {A} {τ} {τ'} =
  tset-map
    (λ {t} h →
      pack-⇒ᵗ
        (tset-map
          (λ pc →
            T-alg-of-handlerˢ h
              (unpack-homᵒ t (proj₁ (unpack-×ᵗ pc)))
              (proj₂ (unpack-×ᵗ pc)))
          (λ p qc →
            trans
              (cong₂ (T-alg-of-handlerˢ h)
                {u = proj₂ (unpack-×ᵗ (monotone (homᵒ t ×ᵗ Tᵒ (Tᵒ A τ') τ) p qc))}
                {v = Tˢ-≤t p (proj₂ (unpack-×ᵗ qc))}
                (≤-irrelevant _ _)
                (sym (cong proj₂ (unpack-×ᵗ-monotone {homᵒ t} {Tᵒ (Tᵒ A τ') τ} p qc))))
              (T-alg-of-handlerˢ-≤t-cod-nat _ h p (proj₂ (unpack-×ᵗ qc))))))
    (λ {t} {t'} p h →
      trans
        (cong pack-⇒ᵗ
          (dcong₂ tset-map
            (ifun-ext (λ {t''} → fun-ext (λ qc →
              trans
                (T-alg-of-handlerˢ-≤t-nat p h _ (proj₂ (unpack-×ᵗ qc)))
                (cong₂ (T-alg-of-handlerˢ {A} {τ} {τ'} {t} h)
                  {u = proj₂ (unpack-×ᵗ qc)}
                  {v = proj₂ (unpack-×ᵗ {_} {Tᵒ (Tᵒ A τ') τ} {t''} (pack-×ᵗ (pack-homᵒ t (≤-trans p (unpack-homᵒ t' (proj₁ (unpack-×ᵗ qc)))) , proj₂ (unpack-×ᵗ qc))))}
                  (≤-irrelevant _ _)
                  (sym (cong proj₂ (pack-unpack-×ᵗ (pack-homᵒ t (≤-trans p (unpack-homᵒ t' (proj₁ (unpack-×ᵗ qc)))) , proj₂ (unpack-×ᵗ qc)))))) )))
            (ifun-ext (ifun-ext (fun-ext (λ q → fun-ext (λ rc → uip)))))))
        (sym (pack-⇒ᵗ-monotone p _)))

