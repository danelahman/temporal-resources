---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad.Core where

-- Interpretation of ground types
---------------------------------

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ   = ConstTSet (BaseSet B)
⟦ Unit ⟧ᵍ     = 𝟙ᵗ
⟦ Empty ⟧ᵍ    = 𝟘ᵗ
⟦ [ τ ]ᵍ A ⟧ᵍ = [ τ ]ᵒ ⟦ A ⟧ᵍ


-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Object mapping and time-monotonicity

mutual

  data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where

    leaf  : ∀ {t}
          → carrier A t
          → Tˢ A 0 t
       
    node  : ∀ {τ t}
          → (op : Op)
          → carrier ⟦ param op ⟧ᵍ t
          → (k : {t' : Time} → t + op-time op ≤ t'
                             → carrier ⟦ arity op ⟧ᵍ t'
                             → Tˢ A τ t')
          → ({t' t'' : Time} → (p : t' ≤ t'')                                       -- time-naturality of continuation
                             → (q : t + op-time op ≤ t')
                             → (y : carrier ⟦ arity op ⟧ᵍ t')
                             → k (≤-trans q p) (monotone (⟦ arity op ⟧ᵍ) p y)
                             ≡ Tˢ-≤t p (k q y))
          → Tˢ A (op-time op + τ) t
     
    delay : ∀ {τ' t}
          → (τ : Time)
          → Tˢ A τ' (t + τ)
          → Tˢ A (τ + τ') t


  Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
  Tˢ-≤t {A} p (leaf v) =
    leaf (monotone A p v)
  Tˢ-≤t p (node op v k k-nat) =
    node op
      (monotone (⟦ param op ⟧ᵍ) p v)
      (λ q y → k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)
      (λ p q y →
        trans
          (cong (λ q → k q (monotone ⟦ arity op ⟧ᵍ p y)) (≤-irrelevant _ _))
          (k-nat _ _ y))
  Tˢ-≤t p (delay τ k) =
    delay τ (Tˢ-≤t (+-monoˡ-≤ τ p) k)


-- Reflexivity and transitivity of time-monotonicity

Tˢ-≤t-refl : ∀ {A τ t} → (c : Tˢ A τ t) → Tˢ-≤t ≤-refl c ≡ c
Tˢ-≤t-refl {A} (leaf v) =
  cong leaf (monotone-refl A v)
Tˢ-≤t-refl {A = A} {t = t} (node {τ = τ} op v k k-nat) =
  dcong₃ (node op)
    (monotone-refl ⟦ param op ⟧ᵍ v)
    (ifun-ext (fun-ext (λ p → fun-ext (λ y →
      trans
        (cong (λ (k : {t' : Time} → t + op-time op ≤ t' → carrier ⟦ arity op ⟧ᵍ t' → Tˢ A τ t') → k p y)
          {subst (λ _ → {t' : Time} → t + op-time op ≤ t' → carrier ⟦ arity op ⟧ᵍ t' → Tˢ A τ t')
              (monotone-refl ⟦ param op ⟧ᵍ v)
              (λ q → k (≤-trans (+-monoˡ-≤ (op-time op) ≤-refl) q))}
          (subst-const _ (monotone-refl ⟦ param op ⟧ᵍ v) _))
        (cong (λ p → k p y) (≤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (λ p → fun-ext (λ q → fun-ext (λ y → uip))))))
Tˢ-≤t-refl (delay τ k) =
  cong (delay τ)
    (trans
      (cong (λ p → Tˢ-≤t p k) (≤-irrelevant _ _))
      (Tˢ-≤t-refl k))

Tˢ-≤t-trans : ∀ {A τ t t' t''}
            → (p : t ≤ t') → (q : t' ≤ t'') → (c : Tˢ A τ t)
            → Tˢ-≤t q (Tˢ-≤t p c) ≡ Tˢ-≤t (≤-trans p q) c
Tˢ-≤t-trans {A} p q (leaf v) =
  cong leaf (monotone-trans A p q v)
Tˢ-≤t-trans {A = A} {t'' = t''} p q (node {τ = τ} op v k k-nat) =
  dcong₃ (node op)
    (monotone-trans (⟦ param op ⟧ᵍ) p q v)
    (ifun-ext (fun-ext (λ r → fun-ext (λ y →
      trans
        (cong (λ (k : {t''' : Time} → t'' + op-time op ≤ t''' → carrier ⟦ arity op ⟧ᵍ t''' → Tˢ A τ t''') → k r y)
          {subst
            (λ _ → {t' = t''' : Time} → t'' + op-time op ≤ t''' → carrier ⟦ arity op ⟧ᵍ t''' → Tˢ A τ t''')
            (monotone-trans ⟦ param op ⟧ᵍ p q v)
            (λ r → k (≤-trans (+-monoˡ-≤ (op-time op) p) (≤-trans (+-monoˡ-≤ (op-time op) q) r)))}
          (subst-const _ (monotone-trans ⟦ param op ⟧ᵍ p q v) _))
        (cong (λ p → k p y) (≤-irrelevant _ _))))))
    (ifun-ext (ifun-ext (fun-ext (λ p → fun-ext (λ q → fun-ext (λ y → uip))))))
Tˢ-≤t-trans p q (delay τ k) =
  cong (delay τ)
    (trans
      (Tˢ-≤t-trans (+-monoˡ-≤ τ p) (+-monoˡ-≤ τ q) k)
      (cong (λ p → Tˢ-≤t p k) (≤-irrelevant _ _)))


-- "subst" for time-gradings

τ-subst : ∀ {A τ τ' t}
        → τ ≡ τ'
        → Tˢ A τ t
        → Tˢ A τ' t
τ-subst refl c = c

τ-subst-≤t : ∀ {A τ τ' t t'}
           → (p : τ ≡ τ')
           → (q : t ≤ t')
           → (c : Tˢ A τ t)
           → Tˢ-≤t q (τ-subst p c) ≡ τ-subst p (Tˢ-≤t q c)
τ-subst-≤t refl q c = refl


-- Functorial action (TODO: prove identity and composition laws)

mutual

  -- TODO: investigate how to convince Agda's termination checker;
  --       the "suspicious" recursive occurrences of `Tˢᶠ` are in 
  --       types (but still applied to the continuation `k`);
  --       so maybe it is enough to index the trees by their height
  --
  --       same also applies for definitions below

  {-# TERMINATING #-}

  Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
  Tˢᶠ f (leaf v) =
    leaf (map-carrier f v)
  Tˢᶠ f (node op v k k-nat) =
    node op v
      (λ p y → Tˢᶠ f (k p y))
      (λ p q y →
        trans
          (cong (Tˢᶠ f) (k-nat p q y))
          (Tˢᶠ-≤t-nat f p (k q y)))    
  Tˢᶠ f (delay τ k) =
    delay τ (Tˢᶠ f k)

  Tˢᶠ-≤t-nat : ∀ {A B τ} → (f : A →ᵗ B) → {t t' : ℕ}
             → (p : t ≤ t') → (c : Tˢ A τ t)
             → Tˢᶠ f (Tˢ-≤t p c) ≡ Tˢ-≤t p (Tˢᶠ f c)
  Tˢᶠ-≤t-nat f p (leaf v) =
    cong leaf (map-nat f p v)
  Tˢᶠ-≤t-nat f p (node op v k k-nat) =
    dcong₃ (node op)
      refl
      refl
      (ifun-ext (ifun-ext (fun-ext (λ p → fun-ext (λ q → fun-ext (λ y → uip))))))
  Tˢᶠ-≤t-nat f p (delay τ k) =
    cong (delay τ) (Tˢᶠ-≤t-nat f (+-monoˡ-≤ τ p) k)


-- Packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (Tˢ A τ) Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans
 
Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f) (Tˢᶠ-≤t-nat f)


-- Unit (TODO: prove naturality and laws)

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ =
  tset-map
    (λ v → leaf v)
    (λ p v → refl)


-- Multiplication (TODO: prove naturality and laws)

mutual

  {-# TERMINATING #-}

  μˢ : ∀ {A τ τ'} → {t : Time}
     → Tˢ (Tᵒ A τ') τ t → Tˢ A (τ + τ') t
  μˢ (leaf c) =
    c
  μˢ (node op v k k-nat) =
    τ-subst
      (sym (+-assoc (op-time op) _ _))
      (node op v
        (λ p y → μˢ (k p y))
        (λ p q y →
          trans
            (cong μˢ (k-nat p q y))
            (μˢ-≤t-nat p (k q y))))
  μˢ (delay τ k) =
    τ-subst (sym (+-assoc τ _ _)) (delay τ (μˢ k))

  μˢ-≤t-nat : ∀ {A τ τ'} → {t t' : ℕ}
          → (p : t ≤ t')
          → (c : Tˢ (Tᵒ A τ') τ t)
          → μˢ (Tˢ-≤t p c) ≡ Tˢ-≤t p (μˢ c)
  μˢ-≤t-nat p (leaf v) =
    refl
  μˢ-≤t-nat p (node op v k k-nat) =
    trans
      (cong (τ-subst (sym (+-assoc (op-time op) _ _)))
        (dcong₂ (node op (monotone ⟦ param op ⟧ᵍ p v))
          refl
          (ifun-ext (ifun-ext (fun-ext (λ q → fun-ext (λ r → fun-ext (λ y → uip))))))))
      (sym (τ-subst-≤t (sym (+-assoc (op-time op) _ _)) p _))
  μˢ-≤t-nat p (delay τ k) =
    trans
      (cong
        (τ-subst (sym (+-assoc τ _ _)))
        (cong (delay τ) (μˢ-≤t-nat (+-monoˡ-≤ τ p) k)))
      (sym (τ-subst-≤t (sym (+-assoc τ _ _)) p (delay τ (μˢ k))))

μᵀ : ∀ {A τ τ'}
   → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')
μᵀ = tset-map μˢ μˢ-≤t-nat

































---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------


{-


-- Candidate for object-mapping of the underlying functor to support quotienting by delay equations
-- NOTE: quick sketch, does not include naturality condition for operation nodes


mutual
  
  data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                            -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    delay : ∀ {τ' t}
          → (τ : Time)
          → 0 < τ
          → Tᶜˢ A τ' (t + τ)
          → Tˢ A (τ + τ') t
    comp  : ∀ {τ t}
          → Tᶜˢ A τ t
          → Tˢ A τ t
  data Tᶜˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                             -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
    leaf  : ∀ {t}
          → carrier A t
          → Tᶜˢ A 0 t
     
    node  : ∀ {τ t}
          → (op : Op)
          → carrier ⟦ param op ⟧ᵍ t
          → ({t' : Time} → t + op-time op ≤ t'
                         → carrier ⟦ arity op ⟧ᵍ t'
                         → Tˢ A τ t')
          → Tᶜˢ A (op-time op + τ) t

-}
