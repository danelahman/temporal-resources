---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past
open import Semantics.Monad.Core

open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.Monad.Strength where

-- The free graded monad generated by the operations in Op (continued)
----------------------------------------------------------------------

-- Strength

mutual

  {-# TERMINATING #-}

  strˢ : ∀ {A B τ τ' t}
       → carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t
       → Tˢ B τ t
       → Tˢ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ t
  strˢ {A} {B} {τ' = τ'} {t} v (leaf w) =
    leaf
      (pack-×ᵗ
        ((≤-trans (proj₁ v) (≤-reflexive (+-identityʳ _)) ,
           monotone A
             (≤-reflexive (cong (_∸ τ') (+-identityʳ _)))
             (proj₂ v)) ,
         w))
  strˢ {A} {B} {_} {τ'} {t} v (node op w k k-nat) =
    node op w
      (λ p y →
        strˢ {A} {B}
          ((monotone (⟨ τ' ⟩ᵒ A)
             (≤-trans
               (≤-reflexive (sym (+-assoc t _ _)))
               (+-monoˡ-≤ _ p))
             v))
          (k p y))
      (λ p q y →
        trans
          (cong₂ strˢ
            (cong₂ _,_
              (≤-irrelevant _ _)
              (trans
                (cong (λ p → monotone A p (proj₂ v))
                  (≤-irrelevant _ _))
                (sym
                  (monotone-trans A _
                    (∸-monoˡ-≤ τ' (+-monoˡ-≤ _ p))
                    (proj₂ v)))))
            (k-nat p q y))
          (strˢ-≤t-nat p _ (k q y)))
  strˢ {A} {B} {_} {τ'} {t} v (delay τ k) =
    delay τ
      (strˢ {A} {B}
        (monotone (⟨ τ' ⟩ᵒ A) (≤-reflexive (sym (+-assoc t _ _))) v)
        k)
     
  strˢ-≤t-nat : ∀ {A B τ τ'} → {t t' : ℕ} → (p : t ≤ t')
              → (v : carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t)
              → (c : Tˢ B τ t)
              → strˢ {A = A} {B = B}
                  (monotone ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) p v)
                  (Tˢ-≤t p c)
              ≡ Tˢ-≤t p (strˢ {A = A} {B = B} v c)
  strˢ-≤t-nat {A} {B} p v (leaf w) =
    cong leaf
      (trans
        (cong pack-×ᵗ
          (cong (_, monotone B p w)
            (cong₂ _,_
              (≤-irrelevant _ _)
              (trans
                (trans
                  (monotone-trans A _ _ (proj₂ v))
                  (cong (λ p → monotone A p (proj₂ v)) (≤-irrelevant _ _)))
                (sym (monotone-trans A _ _ (proj₂ v)))))))
        (sym (pack-×ᵗ-monotone p _)))
  strˢ-≤t-nat {A} {B} p v (node op w k k-nat) =
    dcong₂ (node op (monotone ⟦ param op ⟧ᵍ p w))
      (ifun-ext (fun-ext (λ q → fun-ext (λ y →
        cong (λ v → strˢ {A} {B} v (k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y))
          (cong₂ _,_
            (≤-irrelevant _ _)
            (trans
              (monotone-trans A _ _ (proj₂ v))
              (cong (λ p → monotone A p (proj₂ v)) (≤-irrelevant _ _))))))))
      (ifun-ext (ifun-ext (fun-ext (λ q → fun-ext (λ r → fun-ext (λ y → uip))))))
  strˢ-≤t-nat {A} {B} {_} {τ'} {t} {t'} p v (delay τ k) =
    cong (delay τ)
      (trans
        (cong (λ v → strˢ {A} {B} v (Tˢ-≤t (+-monoˡ-≤ _ p) k))
          (cong₂ _,_
            (≤-irrelevant _ _)
            (trans
              (monotone-trans A _ _ (proj₂ v))
              (trans
                (cong (λ p → monotone A p (proj₂ v)) (≤-irrelevant _ _))
                (sym (monotone-trans A _ _ (proj₂ v)))))))
        (strˢ-≤t-nat
          (+-monoˡ-≤ τ p)
          (monotone (⟨ τ' ⟩ᵒ A) (≤-reflexive (sym (+-assoc t _ _))) v)
          k))

strᵀ : ∀ {A B τ τ'}
     → [ τ ]ᵒ (⟨ τ' ⟩ᵒ A) ×ᵗ Tᵒ B τ →ᵗ Tᵒ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ
strᵀ {A} {B} {τ} {τ'} =
  tset-map
    (λ vc → strˢ {A} {B} (proj₁ (unpack-×ᵗ vc)) (proj₂ (unpack-×ᵗ vc)))
    (λ p vc → trans
      (cong₂ strˢ
        (sym (cong proj₁ (unpack-×ᵗ-monotone {[ τ ]ᵒ (⟨ τ' ⟩ᵒ A)} {Tᵒ B τ} p vc)))
        (sym (cong proj₂ (unpack-×ᵗ-monotone {[ τ ]ᵒ (⟨ τ' ⟩ᵒ A)} {Tᵒ B τ} p vc))))
      (strˢ-≤t-nat p _ _))
        
-- Naturality

strˢ-nat : ∀ {A A' B B' τ τ' t}
         → (f : A →ᵗ A')
         → (g : B →ᵗ B')
         → (v : carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t)
         → (c : Tˢ B τ t)
         → map-carrier (strᵀ {A'} {B'} ∘ᵗ mapˣᵗ ([ τ ]ᶠ (⟨ τ' ⟩ᶠ f)) (Tᶠ g)) (pack-×ᵗ (v , c))
         ≡ map-carrier (Tᶠ (mapˣᵗ (⟨ τ' ⟩ᶠ f) g) ∘ᵗ strᵀ {A} {B}) (pack-×ᵗ (v , c))
strˢ-nat {A} {A'} {B} {B'} {_} {τ'} {t} f g v (leaf w) =
  trans
    (∘ᵗ-reveal (strᵀ {A'} {B'}) (mapˣᵗ ([ 0 ]ᶠ (⟨ τ' ⟩ᶠ f)) (Tᶠ g)) (pack-×ᵗ (v , leaf w)))
    (trans
      (trans
        (trans
          (cong (map-carrier strᵀ)
            (⟨⟩ᵗ-reveal _ _ (pack-×ᵗ (v , leaf w))) )
          (trans
            (cong₂ strˢ
              (cong proj₁ (pack-unpack-×ᵗ _))
              (cong proj₂ (pack-unpack-×ᵗ _)))
            (trans
              (cong₂ strˢ
                (∘ᵗ-reveal _ _ (pack-×ᵗ (v , leaf w)))
                (∘ᵗ-reveal _ _ (pack-×ᵗ (v , leaf w))))
              (trans
                (cong₂ strˢ
                  (cong (map-carrier ([ 0 ]ᶠ (⟨ τ' ⟩ᶠ f))) (fstᵗ-reveal _))
                  (cong (Tˢᶠ g) (sndᵗ-reveal _)))
                (trans
                  (cong₂ strˢ
                    (cong (λ xy → map-carrier ([ 0 ]ᶠ (⟨ τ' ⟩ᶠ f)) (proj₁ xy))
                      (pack-unpack-×ᵗ (v , leaf w)))
                    (cong (λ xy → Tˢᶠ g (proj₂ xy)) (pack-unpack-×ᵗ (v , leaf w))))
                  (cong leaf
                    (trans
                      (cong pack-×ᵗ
                        (cong₂ _,_
                          (trans
                            (trans
                              (trans
                                (trans
                                  (cong₂ _,_
                                    (≤-irrelevant _ _)
                                    (trans
                                      (cong (monotone A' (≤-reflexive (cong (_∸ τ') (+-identityʳ t))))
                                        (trans
                                          (cong proj₂ ([]-reveal 0 (⟨ τ' ⟩ᶠ f) v))
                                          (cong proj₂ (⟨⟩-reveal τ' f v))))
                                      (sym (map-nat f _ _))))
                                  (sym
                                    (⟨⟩-reveal _ _ _)))
                                (sym
                                  (cong (λ xy → map-carrier (⟨ τ' ⟩ᶠ f) (proj₁ xy))
                                    (pack-unpack-×ᵗ _))))
                              (sym
                                (cong (map-carrier (⟨ τ' ⟩ᶠ f))
                                  (fstᵗ-reveal _))))
                            (sym (∘ᵗ-reveal _ _ _)))
                          (trans
                            (cong (map-carrier g)
                              (trans
                                (cong proj₂ (sym (pack-unpack-×ᵗ _)))
                                (sym (sndᵗ-reveal _))))
                            (sym (∘ᵗ-reveal _ _ _)))))
                      (sym
                        (⟨⟩ᵗ-reveal _ _ _)))))))))
        (sym
          (cong (Tˢᶠ ⟨ ⟨ τ' ⟩ᶠ f ∘ᵗ fstᵗ , g ∘ᵗ sndᵗ ⟩ᵗ)
            (cong₂ (strˢ {A} {B})
              (cong proj₁ (pack-unpack-×ᵗ (v , leaf w)))
              (cong proj₂ (pack-unpack-×ᵗ (v , leaf w)))))))
      (sym (∘ᵗ-reveal (Tᶠ (mapˣᵗ (⟨ τ' ⟩ᶠ f) g)) (strᵀ {A} {B}) (pack-×ᵗ (v , leaf w)))))
strˢ-nat f g v (node op w k k-nat) =
  {!!}
strˢ-nat f g v (delay τ k) =
  {!!}



{-
         → strˢ {A'} {B'}
             (map-carrier ([ τ ]ᶠ (⟨ τ' ⟩ᶠ f)) v)
             (Tˢᶠ g c)
         ≡ Tˢᶠ (mapˣᵗ (⟨ τ' ⟩ᶠ f) g) (strˢ {A} {B} v c)
-}



{-
strᵀ-nat : ∀ {A A' B B' τ τ'}
         → (f : A →ᵗ A')
         → (g : B →ᵗ B')
         →  strᵀ {A'} {B'} ∘ᵗ mapˣᵗ ([ τ ]ᶠ (⟨ τ' ⟩ᶠ f)) (Tᶠ g)
         ≡ᵗ Tᶠ (mapˣᵗ (⟨ τ' ⟩ᶠ f) g) ∘ᵗ strᵀ {A} {B}
strᵀ-nat {A} {A'} {B} {B'} {τ} {τ'} f g =
  eqᵗ (λ vc →
    trans
      (cong (map-carrier (strᵀ ∘ᵗ mapˣᵗ ([ τ ]ᶠ (⟨ τ' ⟩ᶠ f)) (Tᶠ g)))
        (sym (unpack-pack-×ᵗ vc)))
      (trans
        (strˢ-nat f g (proj₁ (unpack-×ᵗ vc)) (proj₂ (unpack-×ᵗ vc)))
        (cong (map-carrier (Tᶠ (mapˣᵗ (⟨ τ' ⟩ᶠ f) g) ∘ᵗ strᵀ {A} {B}))
          (unpack-pack-×ᵗ vc))))
-}

-- Laws (TODO)

-- ...
