---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

-- Note: A version of the monad that is not quotioned by
--       the delay equations (identity and composition)

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past

open import Util.HProp
open import Util.Equality
open import Util.Operations
open import Util.Time

module Semantics.NoQuotientMonad where

-- Interpretation of ground types
---------------------------------

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ   = ConstTSet (BaseSet B)
⟦ Unit ⟧ᵍ     = 𝟙ᵗ
⟦ Empty ⟧ᵍ    = 𝟘ᵗ
⟦ [ τ ]ᵍ A ⟧ᵍ = [ τ ]ᵒ ⟦ A ⟧ᵍ

-- The free graded monad generated by the operations in Op
----------------------------------------------------------

-- Skeletal object mapping

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (presheaf index)
  leaf  : ∀ {t}
        → carrier A t
        → Tˢ A 0 t
     
  node  : ∀ {τ t}
        → (op : Op)
        → carrier ⟦ param op ⟧ᵍ t
        → ({t' : Time} → t + op-time op ≤ t'
                       → carrier ⟦ arity op ⟧ᵍ t'
                       → Tˢ A τ t')
        → Tˢ A (op-time op + τ) t

  delay : ∀ {τ' t}
        → (τ : Time)
        → Tˢ A τ' (t + τ)
        → Tˢ A (τ + τ') t


-- Monotonicity with respect to the (presheaf) time indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {A} p (leaf v) =
  leaf (monotone A p v)
Tˢ-≤t p (node op v k) =
  node op
    (monotone (⟦ param op ⟧ᵍ) p v)
    (λ q y → k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)
Tˢ-≤t p (delay τ k) =
  delay τ (Tˢ-≤t (+-monoˡ-≤ τ p) k)

Tˢ-≤t-refl : ∀ {A τ t} → (c : Tˢ A τ t) → Tˢ-≤t ≤-refl c ≡ c
Tˢ-≤t-refl {A} (leaf v) =
  cong leaf (monotone-refl A v)
Tˢ-≤t-refl (node op v k) =
  cong₂ (node op)
    (monotone-refl ⟦ param op ⟧ᵍ v)
    (ifun-ext (fun-ext (λ p → fun-ext (λ y → cong (λ p → k p y) (≤-irrelevant _ _)))))
Tˢ-≤t-refl (delay τ k) =
  cong (delay τ)
    (trans
      (cong (λ p → Tˢ-≤t p k) (≤-irrelevant _ _))
      (Tˢ-≤t-refl k))

Tˢ-≤t-trans : ∀ {A τ t t' t''}
            → (p : t ≤ t') → (q : t' ≤ t'') → (c : Tˢ A τ t)
            → Tˢ-≤t q (Tˢ-≤t p c) ≡ Tˢ-≤t (≤-trans p q) c
Tˢ-≤t-trans {A} p q (leaf v) =
  cong leaf (monotone-trans A p q v)
Tˢ-≤t-trans p q (node op v k) =
  cong₂ (node op)
    (monotone-trans (⟦ param op ⟧ᵍ) p q v)
    (ifun-ext (fun-ext (λ r → fun-ext (λ y → cong (λ p → k p y) (≤-irrelevant _ _)))))
Tˢ-≤t-trans p q (delay τ k) =
  cong (delay τ)
    (trans
      (Tˢ-≤t-trans (+-monoˡ-≤ τ p) (+-monoˡ-≤ τ q) k)
      (cong (λ p → Tˢ-≤t p k) (≤-irrelevant _ _)))


-- "subst" for time-gradings

τ-subst : ∀ {A τ τ' t}
        → τ ≡ τ'
        → Tˢ A τ t
        → Tˢ A τ' t
τ-subst refl c = c

τ-subst-≤t : ∀ {A τ τ' t t'}
           → (p : τ ≡ τ')
           → (q : t ≤ t')
           → (c : Tˢ A τ t)
           → Tˢ-≤t q (τ-subst p c) ≡ τ-subst p (Tˢ-≤t q c)
τ-subst-≤t refl q c = refl

τ-subst-delay : ∀ {A τ τ' τ'' t}
              → (p : τ' ≡ τ'')
              → (c : Tˢ A τ' (t + τ))
              → τ-subst (cong (τ +_) p) (delay τ c) ≡ delay τ (τ-subst p c)
τ-subst-delay refl c = refl


-- Functorial action (TODO: prove identity and composition laws)

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ f (leaf v) =
  leaf (map-carrier f v)
Tˢᶠ f (node op v k) =
  node op v λ p y → Tˢᶠ f (k p y)
Tˢᶠ f (delay τ k) =
  delay τ (Tˢᶠ f k)

Tˢᶠ-≤t-nat : ∀ {A B τ} → (f : A →ᵗ B) → {t t' : ℕ}
           → (p : t ≤ t') → (c : Tˢ A τ t)
           → Tˢᶠ f (Tˢ-≤t p c) ≡ Tˢ-≤t p (Tˢᶠ f c)
Tˢᶠ-≤t-nat f p (leaf v) =
  cong leaf (map-nat f p v)
Tˢᶠ-≤t-nat f p (node op v k) =
  cong₂ (node op) refl refl
Tˢᶠ-≤t-nat f p (delay τ k) =
  cong (delay τ) (Tˢᶠ-≤t-nat f (+-monoˡ-≤ τ p) k)


-- Packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (Tˢ A τ) Tˢ-≤t Tˢ-≤t-refl Tˢ-≤t-trans

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f) (Tˢᶠ-≤t-nat f)


-- Unit (TODO: prove naturality)

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ =
  tset-map
    (λ v → leaf v)
    (λ p v → refl)


-- Multiplication (TODO: prove naturality)

μˢ : ∀ {A τ τ'} → {t : Time}
   → Tˢ (Tᵒ A τ') τ t → Tˢ A (τ + τ') t
μˢ (leaf c) =
  c
μˢ {A = A} {t = t} (node op v k) =
  τ-subst
    (sym (+-assoc (op-time op) _ _))
    (node op v (λ p y → μˢ (k p y)))
μˢ {A = A} {t = t} (delay τ k) =
  τ-subst (sym (+-assoc τ _ _)) (delay τ (μˢ k))

μˢ-≤t-nat : ∀ {A τ τ'} → {t t' : ℕ}
          → (p : t ≤ t')
          → (c : Tˢ (Tᵒ A τ') τ t)
          → μˢ (Tˢ-≤t p c) ≡ Tˢ-≤t p (μˢ c)
μˢ-≤t-nat p (leaf v) =
  refl
μˢ-≤t-nat p (node op v k) =
  (sym (τ-subst-≤t
    (sym (+-assoc (op-time op) _ _)) p
    (node op v (λ q y → μˢ (k q y)))))
μˢ-≤t-nat p (delay τ k) =
  trans
    (cong
      (τ-subst (sym (+-assoc τ _ _)))
      (cong (delay τ) (μˢ-≤t-nat (+-monoˡ-≤ τ p) k)))
    (sym (τ-subst-≤t (sym (+-assoc τ _ _)) p (delay τ (μˢ k))))

μᵀ : ∀ {A τ τ'}
   → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')
μᵀ = tset-map μˢ μˢ-≤t-nat


-- Strength

strˢ : ∀ {A B τ τ' t}
     → carrier ([ τ ]ᵒ (⟨ τ' ⟩ᵒ A)) t
     → Tˢ B τ t
     → Tˢ (⟨ τ' ⟩ᵒ A ×ᵗ B) τ t

strˢ {A} {τ' = τ'} v (leaf w) =
  leaf ((≤-trans (proj₁ v) (≤-reflexive (+-identityʳ _)) ,
         monotone A
           (≤-reflexive (cong (_∸ τ') (+-identityʳ _)))
           (proj₂ v)) ,
        w)
strˢ v (node op w k) = {!!}
strˢ v (delay τ k) = {!!}
