---------------------------------------------------------
-- Free graded monad generated by algebraic operations --
---------------------------------------------------------

module Semantics.Monad.Handling where

open import Function

open import Data.Empty
open import Data.Product
open import Data.Unit hiding (_≤_)

open import Semantics.TSets
open import Semantics.Modality.Future
open import Semantics.Modality.Past
open import Semantics.Monad.Core

open import Util.Equality
open import Util.Operations
open import Util.Time

-- Effect handling for the monad generated by the operations in Op
------------------------------------------------------------------

-- T-algebra induced by an effect handler

mutual

  {-# TERMINATING #-}

  T-alg-of-handlerˢ : ∀ {A τ τ' t}
                    → carrier (Π Op (λ op → Π Time (λ τ'' →
                        ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                          ⇒ᵗ Tᵒ A (op-time op + τ'')))) t
                    → {t' : Time}
                    → t ≤ t'
                    → Tˢ (Tᵒ A τ') τ t'
                    → Tˢ A (τ + τ') t'

  T-alg-of-handlerˢ h p (leaf c) =
    c
  T-alg-of-handlerˢ h p (node op v k k-nat) =
    τ-substˢ
      (sym (+-assoc (op-time op) _ _))
      (node op v
        (λ q y → T-alg-of-handlerˢ h (≤-trans p (m+n≤o⇒m≤o _ q)) (k q y))
        (λ q r y →
          trans
            (cong₂ (T-alg-of-handlerˢ h) (≤-irrelevant _ _) (k-nat q r y))
            (T-alg-of-handlerˢ-≤t-cod-nat _ h q (k r y))))
  T-alg-of-handlerˢ h p (delay τ k) =
    τ-substˢ
      (sym (+-assoc τ _ _))
      (delay τ
        (T-alg-of-handlerˢ h (≤-stepsʳ τ p) k))

  T-alg-of-handlerˢ-≤t-cod-nat : ∀ {A τ τ'} → {t t' : ℕ} → (p : t ≤ t')
                               → (h : carrier (Π Op (λ op → Π Time (λ τ'' →
                                        ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                                          ⇒ᵗ Tᵒ A (op-time op + τ'')))) t)
                               → {t'' : Time}
                               → (q : t' ≤ t'')
                               → (c : Tˢ (Tᵒ A τ') τ t')
                               → T-alg-of-handlerˢ h (≤-trans p q) (Tˢ-≤t q c)
                               ≡ Tˢ-≤t q (T-alg-of-handlerˢ h p c)
                           
  T-alg-of-handlerˢ-≤t-cod-nat p h q (leaf v) =
    refl
  T-alg-of-handlerˢ-≤t-cod-nat p h q (node op v k k-nat) =
    trans
      (cong (τ-substˢ (sym (+-assoc (op-time op) _ _)))
        (dcong₂ (node op (monotone ⟦ param op ⟧ᵍ q v))
          (ifun-ext (fun-ext (λ r → fun-ext (λ y →
            cong (λ p → T-alg-of-handlerˢ h p (k (≤-trans (+-monoˡ-≤ (op-time op) q) r) y)) (≤-irrelevant _ _)))))
          (ifun-ext (ifun-ext (fun-ext (λ r → fun-ext (λ s → fun-ext (λ y → uip))))))))
      (τ-substˢ-≤t (sym (+-assoc (op-time op) _ _)) _ _)
  T-alg-of-handlerˢ-≤t-cod-nat p h q (delay τ k) =
    trans
      (cong (τ-substˢ (sym (+-assoc τ _ _)))
        (cong (delay τ)
          (trans
            (cong (λ p → T-alg-of-handlerˢ h p (Tˢ-≤t (+-monoˡ-≤ τ q) k)) (≤-irrelevant _ _))
            (T-alg-of-handlerˢ-≤t-cod-nat (≤-stepsʳ τ p) h (+-monoˡ-≤ τ q) k))))
      (τ-substˢ-≤t (sym (+-assoc τ _ _)) q _)

  T-alg-of-handlerˢ-≤t-nat : ∀ {A τ τ'} → {t t' : ℕ} → (p : t ≤ t')
                           → (h : carrier (Π Op (λ op → Π Time (λ τ'' →
                                    ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                                      ⇒ᵗ Tᵒ A (op-time op + τ'')))) t)
                           → {t'' : Time}
                           → (q : t' ≤ t'')
                           → (c : Tˢ (Tᵒ A τ') τ t'')
                           → T-alg-of-handlerˢ
                               (monotone (Π Op (λ op → Π Time (λ τ'' →
                                           ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ
                                             ⇒ᵗ (Tᵒ A τ''))) ⇒ᵗ Tᵒ A (op-time op + τ'')))) p h)
                               q c
                           ≡ T-alg-of-handlerˢ h (≤-trans p q) c
  T-alg-of-handlerˢ-≤t-nat p h q (leaf v) =
    refl
  T-alg-of-handlerˢ-≤t-nat p h q (node op v k k-nat) =
    cong (τ-substˢ (sym (+-assoc (op-time op) _ _)))
      (dcong₂ (node op v)
        (ifun-ext (fun-ext (λ r → fun-ext (λ y →
          trans
            (T-alg-of-handlerˢ-≤t-nat p h _ (k r y))
            (cong (λ p → T-alg-of-handlerˢ h p (k r y)) (≤-irrelevant _ _))))))
        (ifun-ext (ifun-ext (fun-ext (λ r → fun-ext (λ s → fun-ext (λ y → uip)))))))
  T-alg-of-handlerˢ-≤t-nat p h q (delay τ k) =
    cong (τ-substˢ (sym (+-assoc τ _ _)))
      (cong (delay τ)
        (trans
          (T-alg-of-handlerˢ-≤t-nat p h _ k)
          (cong (λ p → T-alg-of-handlerˢ h p k) (≤-irrelevant _ _))))

T-alg-of-handlerᵀ : ∀ {A τ τ'}
                  → Π Op (λ op → Π Time (λ τ'' →
                     ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ (Tᵒ A τ'')))
                       ⇒ᵗ Tᵒ A (op-time op + τ'')))
                  →ᵗ Tᵒ (Tᵒ A τ') τ ⇒ᵗ Tᵒ A (τ + τ')
T-alg-of-handlerᵀ {A} {τ} {τ'} =
  tset-map
    (λ {t} h →
      pack-⇒ᵗ
        (tset-map
          (λ pc →
            T-alg-of-handlerˢ h
              (unpack-homᵒ t (proj₁ (unpack-×ᵗ pc)))
              (proj₂ (unpack-×ᵗ pc)))
          (λ p qc →
            trans
              (cong₂ (T-alg-of-handlerˢ h)
                {u = proj₂ (unpack-×ᵗ (monotone (homᵒ t ×ᵗ Tᵒ (Tᵒ A τ') τ) p qc))}
                {v = Tˢ-≤t p (proj₂ (unpack-×ᵗ qc))}
                (≤-irrelevant _ _)
                (sym (cong proj₂ (unpack-×ᵗ-monotone {homᵒ t} {Tᵒ (Tᵒ A τ') τ} p qc))))
              (T-alg-of-handlerˢ-≤t-cod-nat _ h p (proj₂ (unpack-×ᵗ qc))))))
    (λ {t} {t'} p h →
      trans
        (cong pack-⇒ᵗ
          (dcong₂ tset-map
            (ifun-ext (λ {t''} → fun-ext (λ qc →
              trans
                (T-alg-of-handlerˢ-≤t-nat p h _ (proj₂ (unpack-×ᵗ qc)))
                (cong₂ (T-alg-of-handlerˢ {A} {τ} {τ'} {t} h)
                  {u = proj₂ (unpack-×ᵗ qc)}
                  {v = proj₂ (unpack-×ᵗ {_} {Tᵒ (Tᵒ A τ') τ} {t''} (pack-×ᵗ (pack-homᵒ t (≤-trans p (unpack-homᵒ t' (proj₁ (unpack-×ᵗ qc)))) , proj₂ (unpack-×ᵗ qc))))}
                  (≤-irrelevant _ _)
                  (sym (cong proj₂ (pack-unpack-×ᵗ (pack-homᵒ t (≤-trans p (unpack-homᵒ t' (proj₁ (unpack-×ᵗ qc)))) , proj₂ (unpack-×ᵗ qc)))))) )))
            (ifun-ext (ifun-ext (fun-ext (λ q → fun-ext (λ rc → uip)))))))
        (sym (pack-⇒ᵗ-monotone p _)))

