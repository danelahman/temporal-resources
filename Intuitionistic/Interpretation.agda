--------------------------------------------------------
-- Interpretation of well-typed terms in time-indexed --
--------------------------------------------------------

open import Function

open import Data.Nat
open import Data.Nat.Properties
open import Data.Product

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Language

open import TSets
open import ComonadModality
open import MonadModality
open import ModalityAdjunction

module Interpretation where

-- Base types are interpreted as constant presheaves

BaseTSet : BaseType → TSet
BaseTSet B = tset (λ _ → BaseSet B) (λ _ → id)

constᵗ : ∀ {B} → BaseSet B → 𝟙ᵗ →ᵗ BaseTSet B
constᵗ c = tset-map (λ _ → c)

-- Interpretation of ground types

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ = BaseTSet B
⟦ Unit ⟧ᵍ   = 𝟙ᵗ
⟦ Empty ⟧ᵍ  = 𝟘ᵗ

⟦⟧ᵍ-constant : (B : GType) → (t t' : Time) → carrier ⟦ B ⟧ᵍ t → carrier ⟦ B ⟧ᵍ t'
⟦⟧ᵍ-constant (Base B) t t' = id
⟦⟧ᵍ-constant Unit     t t' = id
⟦⟧ᵍ-constant Empty    t t' = id

-- Free graded monad generated by algebraic operations in Op

---- object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier ⟦ param op ⟧ᵍ t
       → ({t' : Time} → t + op-time op ≤ t' → carrier (⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')  -- intuitively, [ op-time op ] (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)
       → τ' ≡ op-time op + τ                                                           -- abstracting into a variable for easier recursive defs.
       → Tˢ A τ' t

---- monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {(tset A Af)} p (leaf a) =
  leaf (Af (+-monoʳ-≤ _ p) a)
Tˢ-≤t {(tset A Af)} p (node op v k q) =
  node
    op (monotone ⟦ param op ⟧ᵍ p v)
    (λ q y → Tˢ-≤t ≤-refl (k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)) q

---- monotonicity wrt time-gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {(tset A Af)} p (leaf v) = leaf (Af (+-monoˡ-≤ _ p) v)
Tˢ-≤τ {(tset A Af)} p (node op v k q) =
  node
    op v
    (λ r y → Tˢ-≤τ (proj₂ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (proj₁ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

---- functorial action on →ᵗ

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ (tset-map f) (leaf a)   =
  leaf (f a)
Tˢᶠ (tset-map f) (node op v k q) =
  node op v (λ p y → Tˢᶠ (tset-map f) (k p y)) q

---- packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p)

---- unit of the graded monad

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ = tset-map (λ v → leaf v)

---- T is a [_]-module

T-[]-moduleˢ : ∀ {A τ τ' t} → Tˢ A τ' (t + τ) → Tˢ A (τ + τ') t
T-[]-moduleˢ {tset A Af} {τ} {τ'} {t} (leaf v) =
  leaf (Af (≤-reflexive (trans
                          (trans
                            (cong (τ' +_) (+-comm t τ))
                            (sym (+-assoc τ' τ t)))
                          (cong (_+ t) (+-comm τ' τ)))) v)
T-[]-moduleˢ {tset A Af} {τ} {τ'} {t} (node {τ = τ''} op v k p) =
  node op
    (⟦⟧ᵍ-constant (param op) (t + τ) t v)    -- can't use monotonicity of the parameter type
    (λ {t'} q y → T-[]-moduleˢ (k (≤-trans
                                    (≤-reflexive
                                      (trans
                                        (+-assoc t τ (op-time op))
                                        (trans
                                          (cong (t +_) (+-comm τ (op-time op)))
                                          (sym (+-assoc t (op-time op) τ)))))
                                    (+-monoˡ-≤ τ q))
                                  (monotone ⟦ arity op ⟧ᵍ (m≤m+n t' τ) y)))  -- could also have used ⟦⟧ᵍ-constant
    (trans
      (cong (τ +_) p)
      (trans
        (sym (+-assoc τ (op-time op) τ''))
        (trans
          (cong (_+ τ'') (+-comm τ (op-time op)))
          (+-assoc (op-time op) τ _))))

T-[]-module : ∀ {A τ τ'} → [ τ ]ᵒ (Tᵒ A τ') →ᵗ Tᵒ A (τ + τ')
T-[]-module = tset-map T-[]-moduleˢ

---- Kleisli extension of the graded monad

kl-extˢ : ∀ {A B τ τ'} → {t : Time}
        → carrier (Tᵒ A τ) t
        → carrier ([ τ ]ᵒ (A ⇒ᵗ Tᵒ B τ')) t
        → carrier (Tᵒ B (τ + τ')) t
        
kl-extˢ {A} {B} {τ' = τ'} (leaf {τ} {t} v) f =
  T-[]-moduleˢ
    (monotone
      (Tᵒ B τ')
      (≤-reflexive (+-comm τ t))
      (f (≤-reflexive (+-comm t τ)) v))
kl-extˢ {A = A} {B = B} {τ' = τ'} {t} (node {τ = τ} op v k p) f =
  node op v
    (λ {t'} q y →
      kl-extˢ
        (k q y)
        (λ {t''} r x →
          f (≤-trans
              (≤-trans
                (≤-reflexive (cong (t +_) p))
                (≤-trans
                  (≤-reflexive (sym (+-assoc t (op-time op) τ)))
                  (+-monoˡ-≤ τ q))) r)
            x))
    (trans (cong (_+ τ') p) (+-assoc (op-time op) τ τ'))

kl-extᵀ : ∀ {A B τ τ'} → Tᵒ A τ ×ᵗ [ τ ]ᵒ (A ⇒ᵗ Tᵒ B τ') →ᵗ Tᵒ B (τ + τ')
kl-extᵀ = tset-map (λ (c , f) → kl-extˢ c f)

---- algebraic operations

opᵀ : ∀ {A τ} → (op : Op)
    → ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)) →ᵗ Tᵒ A (op-time op + τ)
opᵀ op = tset-map (λ { (v , k) → node op v k refl })

-- Interpretation of value and computation types

mutual

  ⟦_⟧ᵛ : VType → TSet
  ⟦ Base B ⟧ᵛ  = BaseTSet B
  ⟦ Unit ⟧ᵛ    = 𝟙ᵗ
  ⟦ Empty ⟧ᵛ   = 𝟘ᵗ
  ⟦ A ⇒ C ⟧ᵛ   = ⟦ A ⟧ᵛ ⇒ᵗ ⟦ C ⟧ᶜ
  ⟦ [ τ ] A ⟧ᵛ = [ τ ]ᵒ ⟦ A ⟧ᵛ

  ⟦_⟧ᶜ : CType → TSet
  ⟦ A ‼ τ ⟧ᶜ = Tᵒ ⟦ A ⟧ᵛ τ

  infix 25 ⟦_⟧ᵛ
  infix 25 ⟦_⟧ᶜ

-- Relating the interpretation of ground types and ground type to type conversion

⟦⟧ᵛ-⟦⟧ᵍ : (B : GType) → ⟦ type-of-gtype B ⟧ᵛ →ᵗ ⟦ B ⟧ᵍ
⟦⟧ᵛ-⟦⟧ᵍ (Base B) = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Unit     = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Empty    = idᵗ

⟦⟧ᵍ-⟦⟧ᵛ : (B : GType) → ⟦ B ⟧ᵍ →ᵗ ⟦ type-of-gtype B ⟧ᵛ
⟦⟧ᵍ-⟦⟧ᵛ (Base B) = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Unit     = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Empty    = idᵗ

-- Interpretation of contexts as environments

⟦_⟧ᵉ : Ctx → TSet
⟦ [] ⟧ᵉ      = 𝟙ᵗ
⟦ Γ ∷ A ⟧ᵉ   = ⟦ Γ ⟧ᵉ ×ᵗ ⟦ A ⟧ᵛ
⟦ Γ ⟨ τ ⟩ ⟧ᵉ = ⟨ τ ⟩ᵒ ⟦ Γ ⟧ᵉ

infix 25 ⟦_⟧ᵉ

-- Total delay of an environment as a single ⟨_⟩ modality

env-delay : ∀ {Γ Γ' Γ''} → Γ' , Γ'' split Γ → ⟦ Γ ⟧ᵉ →ᵗ ⟨ ctx-delay Γ'' ⟩ᵒ ⟦ Γ' ⟧ᵉ
env-delay split-[]     = η
env-delay (split-∷ p) = env-delay p ∘ᵗ fstᵗ
env-delay {Γ' = Γ'} {Γ'' = Γ'' ⟨ τ ⟩} (split-⟨⟩ p) =
     ⟨_⟩-≤ {A = ⟦ Γ' ⟧ᵉ} (≤-reflexive (+-comm (ctx-delay Γ'') τ))
  ∘ᵗ μ {A = ⟦ Γ' ⟧ᵉ}
  ∘ᵗ ⟨ τ ⟩ᶠ (env-delay p)

-- Projecting a variable out of an environment

env-var-⟨⟩ : ∀ {Γ A τ} → A ∈[ τ ] Γ → ⟦ Γ ⟧ᵉ →ᵗ ⟨ τ ⟩ᵒ ⟦ A ⟧ᵛ
env-var-⟨⟩ {A = A} Hd                = η ∘ᵗ sndᵗ
env-var-⟨⟩ {A = A} (Tl-∷ x)          = env-var-⟨⟩ x ∘ᵗ fstᵗ
env-var-⟨⟩ {A = A} (Tl-⟨⟩ {τ = τ} x) = μ {A = ⟦ A ⟧ᵛ} ∘ᵗ ⟨ τ ⟩ᶠ (env-var-⟨⟩ x)

env-var : ∀ {Γ A τ} → A ∈[ τ ] Γ → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
env-var {A = A} x = η⁻¹ ∘ᵗ ⟨_⟩-≤ {A = ⟦ A ⟧ᵛ} z≤n ∘ᵗ env-var-⟨⟩ x

-- Interpretation of well-typed value and computation terms

mutual

  ⟦_⟧ᵛᵗ : ∀ {Γ A} → Γ ⊢V⦂ A → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
  
  ⟦ var x ⟧ᵛᵗ = env-var x
  
  ⟦ const c ⟧ᵛᵗ = constᵗ c ∘ᵗ terminalᵗ
  
  ⟦ ⋆ ⟧ᵛᵗ = terminalᵗ
  
  ⟦ lam M ⟧ᵛᵗ = curryᵗ ⟦ M ⟧ᶜᵗ
  
  ⟦ box {τ = τ} V ⟧ᵛᵗ = ([ τ ]ᶠ ⟦ V ⟧ᵛᵗ) ∘ᵗ η⊣ 

  infix 25 ⟦_⟧ᵛᵗ


  ⟦_⟧ᶜᵗ : ∀ {Γ C} → Γ ⊢C⦂ C → ⟦ Γ ⟧ᵉ →ᵗ ⟦ C ⟧ᶜ
  
  ⟦ return V ⟧ᶜᵗ = ηᵀ ∘ᵗ ⟦ V ⟧ᵛᵗ
  
  ⟦ _;_ {τ = τ} M N ⟧ᶜᵗ = kl-extᵀ ∘ᵗ ⟨ ⟦ M ⟧ᶜᵗ ,
                                          ([ τ ]ᶠ (curryᵗ ⟦ N ⟧ᶜᵗ))
                                       ∘ᵗ η⊣  ⟩ᵗ
  
  ⟦ V · W ⟧ᶜᵗ = appᵗ ∘ᵗ ⟨ ⟦ V ⟧ᵛᵗ , ⟦ W ⟧ᵛᵗ ⟩ᵗ
  
  ⟦ absurd V ⟧ᶜᵗ = initialᵗ ∘ᵗ ⟦ V ⟧ᵛᵗ
  
  ⟦ perform op V M ⟧ᶜᵗ =
     opᵀ op ∘ᵗ ⟨ ⟦⟧ᵛ-⟦⟧ᵍ (param op) ∘ᵗ ⟦ V ⟧ᵛᵗ ,
                    [ op-time op ]ᶠ (curryᵗ (⟦ M ⟧ᶜᵗ ∘ᵗ mapˣᵗ idᵗ (⟦⟧ᵍ-⟦⟧ᵛ (arity op))))
                 ∘ᵗ η⊣ ⟩ᵗ
                 
  ⟦ unbox {Γ'} {τ = τ} p q V M ⟧ᶜᵗ =
    ⟦ M ⟧ᶜᵗ ∘ᵗ ⟨ idᵗ ,
                    ε⊣
                 ∘ᵗ (⟨ τ ⟩ᶠ ⟦ V ⟧ᵛᵗ)
                 ∘ᵗ ⟨_⟩-≤ {A = ⟦ Γ' ⟧ᵉ}  q
                 ∘ᵗ env-delay p ⟩ᵗ

  ⟦ delay τ refl M ⟧ᶜᵗ =
       T-≤τ (≤-reflexive (+-comm τ _))
    ∘ᵗ T-[]-module ∘ᵗ ([ τ ]ᶠ ⟦ M ⟧ᶜᵗ)
    ∘ᵗ η⊣ 

  infix 25 ⟦_⟧ᶜᵗ
