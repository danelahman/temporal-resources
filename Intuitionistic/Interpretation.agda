--------------------------------------------------------
-- Interpretation of well-typed terms in time-indexed --
--------------------------------------------------------

open import Function

open import Data.Nat
open import Data.Nat.Properties
open import Data.Product

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Language
open import TSets

module Interpretation where

-- Base types are interpreted as constant presheaves

BaseTSet : BaseType → TSet
BaseTSet B = tset (λ _ → BaseSet B) (λ _ → id)

-- Interpretation of ground types

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ = BaseTSet B
⟦ Unit ⟧ᵍ   = 𝟙ᵗ
⟦ Empty ⟧ᵍ  = 𝟘ᵗ

⟦⟧ᵍ-constant : (B : GType) → (t t' : Time) → carrier ⟦ B ⟧ᵍ t → carrier ⟦ B ⟧ᵍ t'
⟦⟧ᵍ-constant (Base B) t t' = id
⟦⟧ᵍ-constant Unit     t t' = id
⟦⟧ᵍ-constant Empty    t t' = id

-- Free graded monad generated by algebraic operations

---- object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (monad's grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier ⟦ param op ⟧ᵍ t
       → ((t' : Time) → t ≤ t' → carrier (⟨ op-time op ⟩ᵒ ⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')
       → τ' ≡ op-time op + τ
       → Tˢ A τ' t

---- interaction between gradings and TSets' time indices

Tˢ-move-+ : ∀ {A τ τ' t} → Tˢ A τ (τ' + t) → Tˢ A (τ' + τ) t
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (leaf v) =
  leaf (Af (≤-reflexive (trans (sym (+-assoc τ τ' t)) (cong (_+ t) (+-comm τ τ')))) v)
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (node op v k q) =
  node op
    (⟦⟧ᵍ-constant (param op) (τ' + t) t v)
    (λ { t' r (s , y) → Tˢ-move-+ (k (τ' + t')
                                     (+-mono-≤ ≤-refl r)
                                     (≤-stepsˡ τ' s ,
                                      ⟦⟧ᵍ-constant (arity op) (t' ∸ op-time op) (τ' + t' ∸ op-time op) y))})
    (trans
      (+-comm τ' τ)
      (trans
        (cong (_+ τ') q)
        (trans
          (+-assoc (op-time op) _ τ')
          (cong (op-time op +_) (+-comm _ τ')))))

---- monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {(tset A Af)} p (leaf a) =
  leaf (Af (+-mono-≤ ≤-refl p) a)
Tˢ-≤t {(tset A Af)} p (node op v k q) =
  node
    op (monotone ⟦ param op ⟧ᵍ p v)
    (λ t' q y → Tˢ-≤t ≤-refl (k t' (≤-trans p q) y)) q

---- monotonicity wrt gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {(tset A Af)} p (leaf v) = leaf (Af (+-mono-≤ p ≤-refl) v)
Tˢ-≤τ {(tset A Af)} p (node op v k q) =
  node
    op v
    (λ t' r y → Tˢ-≤τ (proj₂ (proj₂ (≤-split-+ (trans q (+-comm (op-time op) _)) p))) (k t' r y))
    (trans (proj₁ (proj₂ (≤-split-+ (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

---- functorial action on TSet-maps

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ (tset-map f) (leaf a)   =
  leaf (f a)
Tˢᶠ (tset-map f) (node op v k q) =
  node op v (λ t' p y → Tˢᶠ (tset-map f) (k t' p y)) q

---- packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p)

---- unit of the graded monad

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ = tset-map (λ v → leaf v)

---- Kleisli extension of the graded monad

extendˢ : ∀ {A B τ τ'} → A →ᵗ Tᵒ B τ' → {t : Time} → Tˢ A τ t → Tˢ B (τ + τ') t
extendˢ (tset-map f) (leaf v) = Tˢ-move-+ (f v)
extendˢ {τ = τ} {τ' = τ'} (tset-map f) (node op v k q) =
  node op v
    (λ t' r y → extendˢ (tset-map f) (k t' r y))
    (trans (cong (_+ _) q) (+-assoc (op-time op) _ _))

extendᵀ : ∀ {A B τ τ'} → A →ᵗ Tᵒ B τ' → Tᵒ A τ →ᵗ Tᵒ B (τ + τ')
extendᵀ f = tset-map (extendˢ f)

---- Algebraic operations associated with the graded monad

opᵗ : ∀ {A τ τ'}
    → (op : Op) → τ' ≡ op-time op + τ
    → ⟦ param op ⟧ᵍ ×ᵗ (⟨ op-time op ⟩ᵒ ⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ) →ᵗ Tᵒ A τ'
opᵗ op p = tset-map λ { (v , k) → node op v k p }

-- Interpretation of value and computation types

mutual

  ⟦_⟧ᵛ : VType → TSet
  ⟦ Base B ⟧ᵛ  = BaseTSet B
  ⟦ Unit ⟧ᵛ    = 𝟙ᵗ
  ⟦ Empty ⟧ᵛ   = 𝟘ᵗ
  ⟦ A ⇒ C ⟧ᵛ   = ⟦ A ⟧ᵛ ⇒ᵗ ⟦ C ⟧ᶜ
  ⟦ [ τ ] A ⟧ᵛ = [ τ ]ᵒ ⟦ A ⟧ᵛ

  ⟦_⟧ᶜ : CType → TSet
  ⟦ A ‼ τ ⟧ᶜ = Tᵒ ⟦ A ⟧ᵛ τ

  infix 25 ⟦_⟧ᵛ
  infix 25 ⟦_⟧ᶜ

-- Relating the interpretation of ground types and ground type to type conversion

⟦⟧ᵛ-⟦⟧ᵍ : (B : GType) → ⟦ type-of-gtype B ⟧ᵛ →ᵗ ⟦ B ⟧ᵍ
⟦⟧ᵛ-⟦⟧ᵍ (Base B) = tset-map id
⟦⟧ᵛ-⟦⟧ᵍ Unit     = tset-map id
⟦⟧ᵛ-⟦⟧ᵍ Empty    = tset-map id

-- Interpretation of contexts as environments

⟦_⟧ᵉ : Ctx → TSet
⟦ [] ⟧ᵉ      = 𝟙ᵗ
⟦ Γ ∷ᶜ A ⟧ᵉ  = ⟦ Γ ⟧ᵉ ×ᵗ ⟦ A ⟧ᵛ
⟦ Γ ⟨ τ ⟩ ⟧ᵉ = ⟨ τ ⟩ᵒ ⟦ Γ ⟧ᵉ

infix 25 ⟦_⟧ᵉ

-- Interpretation of well-typed value and computation terms

mutual

  ⟦_⟧ᵛᵗ : ∀ {Γ A} → Γ ⊢V⦂ A → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
  ⟦ var x ⟧ᵛᵗ         = {!!}
  ⟦ const c ⟧ᵛᵗ       = tset-map (λ _ → c)
  ⟦ ⟨⟩ ⟧ᵛᵗ            = terminalᵗ
  ⟦ lam M ⟧ᵛᵗ         = {!⟦ M ⟧ᶜᵗ!}
  ⟦ box {τ = τ} V ⟧ᵛᵗ = ([ τ ]ᶠ ⟦ V ⟧ᵛᵗ) ∘ᵗ η⊣ 

  ⟦_⟧ᶜᵗ : ∀ {Γ C} → Γ ⊢C⦂ C → ⟦ Γ ⟧ᵉ →ᵗ ⟦ C ⟧ᶜ
  ⟦ return V ⟧ᶜᵗ       = T-≤τ z≤n ∘ᵗ ηᵀ ∘ᵗ ⟦ V ⟧ᵛᵗ
  ⟦ M ; N ⟧ᶜᵗ          = {!!}
  ⟦ V · W ⟧ᶜᵗ          = appᵗ ∘ᵗ ⟨ ⟦ V ⟧ᵛᵗ , ⟦ W ⟧ᵛᵗ ⟩ᵗ
  ⟦ absurd V ⟧ᶜᵗ       = initialᵗ ∘ᵗ ⟦ V ⟧ᵛᵗ
  ⟦ perform op V M ⟧ᶜᵗ = opᵗ op refl ∘ᵗ ⟨ ⟦⟧ᵛ-⟦⟧ᵍ (param op) ∘ᵗ ⟦ V ⟧ᵛᵗ , {!⟦ M ⟧ᶜᵗ!} ⟩ᵗ
  ⟦ unbox V p q ⟧ᶜᵗ    = {!!}
  ⟦ coerce p M ⟧ᶜᵗ     = T-≤τ p ∘ᵗ ⟦ M ⟧ᶜᵗ
