--------------------------------------------------------
-- Interpretation of well-typed terms in time-indexed --
--------------------------------------------------------

open import Function

open import Data.Nat
open import Data.Nat.Properties
open import Data.Product

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Language
open import TSets

module Interpretation where

-- Base types are interpreted as constant presheaves

BaseTSet : BaseType → TSet
BaseTSet B = tset (λ _ → BaseSet B) (λ _ → id)

-- Interpretation of ground types

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ = BaseTSet B
⟦ Unit ⟧ᵍ   = 𝟙ᵗ
⟦ Empty ⟧ᵍ  = 𝟘ᵗ

⟦⟧ᵍ-constant : (B : GType) → (t t' : Time) → carrier ⟦ B ⟧ᵍ t → carrier ⟦ B ⟧ᵍ t'
⟦⟧ᵍ-constant (Base B) t t' = id
⟦⟧ᵍ-constant Unit     t t' = id
⟦⟧ᵍ-constant Empty    t t' = id

-- Free graded monad generated by algebraic operations in Op

---- object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier ⟦ param op ⟧ᵍ t
       → ({t' : Time} → t + op-time op ≤ t' → carrier (⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')  -- intuitively, [ op-time op ] (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)
       → τ' ≡ op-time op + τ                                                           -- abstracting into a variable for easier recursive defs.
       → Tˢ A τ' t

---- monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {(tset A Af)} p (leaf a) =
  leaf (Af (+-monoʳ-≤ _ p) a)
Tˢ-≤t {(tset A Af)} p (node op v k q) =
  node
    op (monotone ⟦ param op ⟧ᵍ p v)
    (λ q y → Tˢ-≤t ≤-refl (k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)) q

---- monotonicity wrt time-gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {(tset A Af)} p (leaf v) = leaf (Af (+-monoˡ-≤ _ p) v)
Tˢ-≤τ {(tset A Af)} p (node op v k q) =
  node
    op v
    (λ r y → Tˢ-≤τ (proj₂ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (proj₁ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

---- functorial action on →ᵗ

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ (tset-map f) (leaf a)   =
  leaf (f a)
Tˢᶠ (tset-map f) (node op v k q) =
  node op v (λ p y → Tˢᶠ (tset-map f) (k p y)) q

---- packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p)

---- unit of the graded monad

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ = tset-map (λ v → leaf v)

---- Kleisli extension (bind) of the graded monad

Tˢ-move-+ : ∀ {A τ τ' t} → Tˢ A τ (τ' + t) → Tˢ A (τ' + τ) t
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (leaf v) =
  leaf (Af (≤-reflexive (trans (sym (+-assoc τ τ' t)) (cong (_+ t) (+-comm τ τ')))) v)
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (node {τ = τ''} op v k q) =
  node op
    (⟦⟧ᵍ-constant (param op) (τ' + t) t v)
    (λ { {t'} r y → Tˢ-move-+ (k (≤-trans (≤-reflexive (+-assoc τ' t (op-time op))) (+-monoʳ-≤ τ' r))
                                 (⟦⟧ᵍ-constant (arity op) t' (τ' + t') y)) })
    (trans
      (trans
        (cong (τ' +_) q)
        (sym (+-assoc τ' (op-time op) τ'')))
      (trans
        (cong (_+ τ'') (+-comm τ' (op-time op)))
        (+-assoc (op-time op) τ' τ'')))
    
extendˢ : ∀ {A B τ τ'} → A →ᵗ Tᵒ B τ' → {t : Time} → Tˢ A τ t → Tˢ B (τ + τ') t
extendˢ (tset-map f) (leaf v) = Tˢ-move-+ (f v)
extendˢ {τ = τ} {τ' = τ'} (tset-map f) (node op v k q) =
  node op v
    (λ r y → extendˢ (tset-map f) (k r y))
    (trans (cong (_+ _) q) (+-assoc (op-time op) _ _))

extendᵀ : ∀ {A B τ τ'} → A →ᵗ Tᵒ B τ' → Tᵒ A τ →ᵗ Tᵒ B (τ + τ')
extendᵀ f = tset-map (extendˢ f)

---- algebraic operations

opᵗ : ∀ {A τ} → (op : Op)
    → ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)) →ᵗ Tᵒ A (op-time op + τ)
opᵗ op = tset-map (λ { (v , k) → node op v k refl })

-- Interpretation of value and computation types

mutual

  ⟦_⟧ᵛ : VType → TSet
  ⟦ Base B ⟧ᵛ  = BaseTSet B
  ⟦ Unit ⟧ᵛ    = 𝟙ᵗ
  ⟦ Empty ⟧ᵛ   = 𝟘ᵗ
  ⟦ A ⇒ C ⟧ᵛ   = ⟦ A ⟧ᵛ ⇒ᵗ ⟦ C ⟧ᶜ
  ⟦ [ τ ] A ⟧ᵛ = [ τ ]ᵒ ⟦ A ⟧ᵛ

  ⟦_⟧ᶜ : CType → TSet
  ⟦ A ‼ τ ⟧ᶜ = Tᵒ ⟦ A ⟧ᵛ τ

  infix 25 ⟦_⟧ᵛ
  infix 25 ⟦_⟧ᶜ

-- Relating the interpretation of ground types and ground type to type conversion

⟦⟧ᵛ-⟦⟧ᵍ : (B : GType) → ⟦ type-of-gtype B ⟧ᵛ →ᵗ ⟦ B ⟧ᵍ
⟦⟧ᵛ-⟦⟧ᵍ (Base B) = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Unit     = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Empty    = idᵗ

⟦⟧ᵍ-⟦⟧ᵛ : (B : GType) → ⟦ B ⟧ᵍ →ᵗ ⟦ type-of-gtype B ⟧ᵛ
⟦⟧ᵍ-⟦⟧ᵛ (Base B) = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Unit     = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Empty    = idᵗ

-- Interpretation of contexts as environments

⟦_⟧ᵉ : Ctx → TSet
⟦ [] ⟧ᵉ      = 𝟙ᵗ
⟦ Γ ∷ᶜ A ⟧ᵉ  = ⟦ Γ ⟧ᵉ ×ᵗ ⟦ A ⟧ᵛ
⟦ Γ ⟨ τ ⟩ ⟧ᵉ = ⟨ τ ⟩ᵒ ⟦ Γ ⟧ᵉ

infix 25 ⟦_⟧ᵉ

-- Interpretation of well-typed value and computation terms

mutual

  ⟦_⟧ᵛᵗ : ∀ {Γ A} → Γ ⊢V⦂ A → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
  ⟦ var x ⟧ᵛᵗ         = {!!}
  ⟦ const c ⟧ᵛᵗ       = tset-map (λ _ → c)
  ⟦ ⟨⟩ ⟧ᵛᵗ            = terminalᵗ
  ⟦ lam M ⟧ᵛᵗ         = curryᵗ ⟦ M ⟧ᶜᵗ
  ⟦ box {τ = τ} V ⟧ᵛᵗ = ([ τ ]ᶠ ⟦ V ⟧ᵛᵗ) ∘ᵗ η⊣ 

  ⟦_⟧ᶜᵗ : ∀ {Γ C} → Γ ⊢C⦂ C → ⟦ Γ ⟧ᵉ →ᵗ ⟦ C ⟧ᶜ
  ⟦ return V ⟧ᶜᵗ       = T-≤τ z≤n ∘ᵗ ηᵀ ∘ᵗ ⟦ V ⟧ᵛᵗ
  ⟦ M ; N ⟧ᶜᵗ          = {!!}
  ⟦ V · W ⟧ᶜᵗ          = appᵗ ∘ᵗ ⟨ ⟦ V ⟧ᵛᵗ , ⟦ W ⟧ᵛᵗ ⟩ᵗ
  ⟦ absurd V ⟧ᶜᵗ       = initialᵗ ∘ᵗ ⟦ V ⟧ᵛᵗ
  ⟦ perform op V M ⟧ᶜᵗ =
     opᵗ op ∘ᵗ ⟨ ⟦⟧ᵛ-⟦⟧ᵍ (param op) ∘ᵗ ⟦ V ⟧ᵛᵗ ,
                 [ op-time op ]ᶠ (curryᵗ (⟦ M ⟧ᶜᵗ ∘ᵗ mapˣᵗ idᵗ (⟦⟧ᵍ-⟦⟧ᵛ (arity op)))) ∘ᵗ η⊣ ⟩ᵗ
  ⟦ unbox V p q ⟧ᶜᵗ    = {!!}
  ⟦ coerce p M ⟧ᶜᵗ     = T-≤τ p ∘ᵗ ⟦ M ⟧ᶜᵗ
