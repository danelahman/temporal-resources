--------------------------------------------------------
-- Interpretation of well-typed terms in time-indexed --
--------------------------------------------------------

open import Function

open import Data.Nat
open import Data.Nat.Properties
open import Data.Product

import Relation.Binary.PropositionalEquality as Eq
open Eq hiding ([_])
open Eq.≡-Reasoning

open import Language
open import TSets

module Interpretation where

-- Base types are interpreted as constant presheaves

BaseTSet : BaseType → TSet
BaseTSet B = tset (λ _ → BaseSet B) (λ _ → id)

constᵗ : ∀ {B} → BaseSet B → 𝟙ᵗ →ᵗ BaseTSet B
constᵗ c = tset-map (λ _ → c)

-- Interpretation of ground types

⟦_⟧ᵍ : GType → TSet
⟦ Base B ⟧ᵍ = BaseTSet B
⟦ Unit ⟧ᵍ   = 𝟙ᵗ
⟦ Empty ⟧ᵍ  = 𝟘ᵗ

⟦⟧ᵍ-constant : (B : GType) → (t t' : Time) → carrier ⟦ B ⟧ᵍ t → carrier ⟦ B ⟧ᵍ t'
⟦⟧ᵍ-constant (Base B) t t' = id
⟦⟧ᵍ-constant Unit     t t' = id
⟦⟧ᵍ-constant Empty    t t' = id

-- Free graded monad generated by algebraic operations in Op

---- object-mapping of the underlying functor

data Tˢ (A : TSet) : (τ : Time) → (t : Time) → Set where  -- 1st time index (τ) is the duration of the computation (its time-grading)
                                                          -- 2nd time index (t) is the corresponding TSets' time-index (modal time)
  leaf : ∀ {τ t}
       → carrier A (τ + t)
       → Tˢ A τ t

  node : ∀ {τ τ' t}
       → (op : Op)
       → carrier ⟦ param op ⟧ᵍ t
       → ({t' : Time} → t + op-time op ≤ t' → carrier (⟦ arity op ⟧ᵍ) t' → Tˢ A τ t')  -- intuitively, [ op-time op ] (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)
       → τ' ≡ op-time op + τ                                                           -- abstracting into a variable for easier recursive defs.
       → Tˢ A τ' t

---- monotonicity wrt TSets' time-indices

Tˢ-≤t : ∀ {A τ t t'} → t ≤ t' → Tˢ A τ t → Tˢ A τ t'
Tˢ-≤t {(tset A Af)} p (leaf a) =
  leaf (Af (+-monoʳ-≤ _ p) a)
Tˢ-≤t {(tset A Af)} p (node op v k q) =
  node
    op (monotone ⟦ param op ⟧ᵍ p v)
    (λ q y → Tˢ-≤t ≤-refl (k (≤-trans (+-monoˡ-≤ (op-time op) p) q) y)) q

---- monotonicity wrt time-gradings

Tˢ-≤τ : ∀ {A τ τ' t} → τ ≤ τ' → Tˢ A τ t → Tˢ A τ' t
Tˢ-≤τ {(tset A Af)} p (leaf v) = leaf (Af (+-monoˡ-≤ _ p) v)
Tˢ-≤τ {(tset A Af)} p (node op v k q) =
  node
    op v
    (λ r y → Tˢ-≤τ (proj₂ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (k r y))
    (trans (proj₁ (proj₂ (n≡m+k≤n' (trans q (+-comm (op-time op) _)) p))) (+-comm _ (op-time op)))

---- functorial action on →ᵗ

Tˢᶠ : ∀ {A B τ} → A →ᵗ B → {t : Time} → Tˢ A τ t → Tˢ B τ t
Tˢᶠ (tset-map f) (leaf a)   =
  leaf (f a)
Tˢᶠ (tset-map f) (node op v k q) =
  node op v (λ p y → Tˢᶠ (tset-map f) (k p y)) q

---- packaging it all up into a functor on TSet

Tᵒ : TSet → Time → TSet
Tᵒ A τ = tset (λ t → Tˢ A τ t) Tˢ-≤t

Tᶠ : ∀ {A B τ} → A →ᵗ B → Tᵒ A τ →ᵗ Tᵒ B τ
Tᶠ f = tset-map (Tˢᶠ f)

T-≤τ : ∀ {A τ τ'} → τ ≤ τ' → Tᵒ A τ →ᵗ Tᵒ A τ'
T-≤τ p = tset-map (Tˢ-≤τ p)

---- unit of the graded monad

ηᵀ : ∀ {A} → A →ᵗ Tᵒ A 0
ηᵀ = tset-map (λ v → leaf v)

---- multiplication of the graded monad

Tˢ-move-+ : ∀ {A τ τ' t} → Tˢ A τ (τ' + t) → Tˢ A (τ' + τ) t
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (leaf v) =
  leaf (Af (≤-reflexive (trans (sym (+-assoc τ τ' t)) (cong (_+ t) (+-comm τ τ')))) v)
Tˢ-move-+ {(tset A Af)} {τ} {τ'} {t} (node {τ = τ''} op v k q) =
  node op
    (⟦⟧ᵍ-constant (param op) (τ' + t) t v)  -- can't use monotonicity of the parameter type
    (λ { {t'} r y → Tˢ-move-+ (k (≤-trans (≤-reflexive (+-assoc τ' t (op-time op))) (+-monoʳ-≤ τ' r))
                                 (monotone ⟦ arity op ⟧ᵍ (m≤n+m t' τ') y)) })  -- could also have used ⟦⟧ᵍ-constant
    (trans
      (trans
        (cong (τ' +_) q)
        (sym (+-assoc τ' (op-time op) τ'')))
      (trans
        (cong (_+ τ'') (+-comm τ' (op-time op)))
        (+-assoc (op-time op) τ' τ'')))


μˢ : ∀ {A τ τ'} → {t : Time} → carrier (Tᵒ (Tᵒ A τ') τ) t → carrier (Tᵒ A (τ + τ')) t
μˢ {tset A Af} (leaf c) = Tˢ-move-+ c
μˢ (node op v k p) =
  node op v (λ q y → μˢ (k q y)) (trans (cong (_+ _) p) (+-assoc (op-time op) _ _))

μᵀ : ∀ {A τ τ'} → Tᵒ (Tᵒ A τ') τ →ᵗ Tᵒ A (τ + τ')
μᵀ = tset-map μˢ

---- strength of the graded monad

---- note: had to mark σˢ as terminating because Agda's termination
---- gets confused trying to see see that subtrees modelled as a
---- function are smaller that the given tree (I guess reindexing the
---- non-recursive argument component with Af is at fault for this)

{-# TERMINATING #-}
σˢ : ∀ {A B τ} → {t : Time} → carrier A t × carrier (Tᵒ B τ) t → carrier (Tᵒ (A ×ᵗ B) τ) t
σˢ {tset A Af} {τ = τ} {t = t} (v , leaf w) =
  leaf (Af (m≤n+m t τ) v , w)
σˢ {tset A Af} {t = t} (v , node op w k p) =
  node op w (λ q y → σˢ (Af (≤-trans (m≤m+n t (op-time op)) q) v , k q y)) p

σᵀ : ∀ {A B τ} → A ×ᵗ Tᵒ B τ →ᵗ Tᵒ (A ×ᵗ B) τ
σᵀ = tset-map σˢ

---- algebraic operations

opᵀ : ∀ {A τ} → (op : Op)
    → ⟦ param op ⟧ᵍ ×ᵗ ([ op-time op ]ᵒ (⟦ arity op ⟧ᵍ ⇒ᵗ Tᵒ A τ)) →ᵗ Tᵒ A (op-time op + τ)
opᵀ op = tset-map (λ { (v , k) → node op v k refl })

-- Interpretation of value and computation types

mutual

  ⟦_⟧ᵛ : VType → TSet
  ⟦ Base B ⟧ᵛ  = BaseTSet B
  ⟦ Unit ⟧ᵛ    = 𝟙ᵗ
  ⟦ Empty ⟧ᵛ   = 𝟘ᵗ
  ⟦ A ⇒ C ⟧ᵛ   = ⟦ A ⟧ᵛ ⇒ᵗ ⟦ C ⟧ᶜ
  ⟦ [ τ ] A ⟧ᵛ = [ τ ]ᵒ ⟦ A ⟧ᵛ

  ⟦_⟧ᶜ : CType → TSet
  ⟦ A ‼ τ ⟧ᶜ = Tᵒ ⟦ A ⟧ᵛ τ

  infix 25 ⟦_⟧ᵛ
  infix 25 ⟦_⟧ᶜ

-- Relating the interpretation of ground types and ground type to type conversion

⟦⟧ᵛ-⟦⟧ᵍ : (B : GType) → ⟦ type-of-gtype B ⟧ᵛ →ᵗ ⟦ B ⟧ᵍ
⟦⟧ᵛ-⟦⟧ᵍ (Base B) = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Unit     = idᵗ
⟦⟧ᵛ-⟦⟧ᵍ Empty    = idᵗ

⟦⟧ᵍ-⟦⟧ᵛ : (B : GType) → ⟦ B ⟧ᵍ →ᵗ ⟦ type-of-gtype B ⟧ᵛ
⟦⟧ᵍ-⟦⟧ᵛ (Base B) = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Unit     = idᵗ
⟦⟧ᵍ-⟦⟧ᵛ Empty    = idᵗ

-- Interpretation of contexts as environments

⟦_⟧ᵉ : Ctx → TSet
⟦ [] ⟧ᵉ      = 𝟙ᵗ
⟦ Γ ∷ᶜ A ⟧ᵉ  = ⟦ Γ ⟧ᵉ ×ᵗ ⟦ A ⟧ᵛ
⟦ Γ ⟨ τ ⟩ ⟧ᵉ = ⟨ τ ⟩ᵒ ⟦ Γ ⟧ᵉ

infix 25 ⟦_⟧ᵉ

-- Total delay of an environment as a single ⟨_⟩ modality

env-delay : ∀ {Γ Γ' Γ''} → Γ' , Γ'' split Γ → ⟦ Γ ⟧ᵉ →ᵗ ⟨ ctx-delay Γ'' ⟩ᵒ ⟦ Γ' ⟧ᵉ
env-delay split-[]     = η
env-delay (split-∷ᶜ p) = env-delay p ∘ᵗ fstᵗ
env-delay {Γ' = Γ'} {Γ'' = Γ'' ⟨ τ ⟩} (split-⟨⟩ p) =
     ⟨_⟩-≤ {A = ⟦ Γ' ⟧ᵉ} (≤-reflexive (+-comm (ctx-delay Γ'') τ))
  ∘ᵗ μ {A = ⟦ Γ' ⟧ᵉ}
  ∘ᵗ ⟨ τ ⟩ᶠ (env-delay p)

-- Projecting a variable out of an environment

env-var : ∀ {Γ A} → A ∈ Γ → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
env-var Hd     = sndᵗ
env-var (Tl x) = env-var x ∘ᵗ fstᵗ

-- Interpretation of well-typed value and computation terms

mutual

  ⟦_⟧ᵛᵗ : ∀ {Γ A} → Γ ⊢V⦂ A → ⟦ Γ ⟧ᵉ →ᵗ ⟦ A ⟧ᵛ
  
  ⟦ var x ⟧ᵛᵗ = env-var x
  
  ⟦ const c ⟧ᵛᵗ = constᵗ c ∘ᵗ terminalᵗ
  
  ⟦ ⋆ ⟧ᵛᵗ = terminalᵗ
  
  ⟦ lam M ⟧ᵛᵗ = curryᵗ ⟦ M ⟧ᶜᵗ
  
  ⟦ box {τ = τ} V ⟧ᵛᵗ = ([ τ ]ᶠ ⟦ V ⟧ᵛᵗ) ∘ᵗ η⊣ 

  infix 25 ⟦_⟧ᵛᵗ


  ⟦_⟧ᶜᵗ : ∀ {Γ C} → Γ ⊢C⦂ C → ⟦ Γ ⟧ᵉ →ᵗ ⟦ C ⟧ᶜ
  
  ⟦ return V ⟧ᶜᵗ = T-≤τ z≤n ∘ᵗ ηᵀ ∘ᵗ ⟦ V ⟧ᵛᵗ
  
  ⟦ M ; N ⟧ᶜᵗ = μᵀ ∘ᵗ Tᶠ ⟦ N ⟧ᶜᵗ ∘ᵗ σᵀ ∘ᵗ ⟨ idᵗ , ⟦ M ⟧ᶜᵗ ⟩ᵗ
  
  ⟦ V · W ⟧ᶜᵗ = appᵗ ∘ᵗ ⟨ ⟦ V ⟧ᵛᵗ , ⟦ W ⟧ᵛᵗ ⟩ᵗ
  
  ⟦ absurd V ⟧ᶜᵗ = initialᵗ ∘ᵗ ⟦ V ⟧ᵛᵗ
  
  ⟦ perform op V M ⟧ᶜᵗ =
     opᵀ op ∘ᵗ ⟨ ⟦⟧ᵛ-⟦⟧ᵍ (param op) ∘ᵗ ⟦ V ⟧ᵛᵗ ,
                 [ op-time op ]ᶠ (curryᵗ (⟦ M ⟧ᶜᵗ ∘ᵗ mapˣᵗ idᵗ (⟦⟧ᵍ-⟦⟧ᵛ (arity op)))) ∘ᵗ η⊣ ⟩ᵗ
                 
  ⟦ unbox {Γ'} {Γ''} {τ = τ} {τ' = τ'} p q V M ⟧ᶜᵗ =
    ⟦ M ⟧ᶜᵗ ∘ᵗ ⟨ idᵗ ,
                    ε⊣
                 ∘ᵗ ⟨ τ ⟩ᶠ ⟦ V ⟧ᵛᵗ
                 ∘ᵗ ⟨_⟩-≤ {A = ⟦ Γ' ⟧ᵉ} (≤-trans q (≤-reflexive (+-comm τ' (ctx-delay Γ''))))
                 ∘ᵗ μ {A = ⟦ Γ' ⟧ᵉ}
                 ∘ᵗ env-delay p ⟩ᵗ
  
  ⟦ coerce p M ⟧ᶜᵗ = T-≤τ p ∘ᵗ ⟦ M ⟧ᶜᵗ

  infix 25 ⟦_⟧ᶜᵗ
